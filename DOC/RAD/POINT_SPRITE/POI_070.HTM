<!DOCTYPE HTML><script> ////////////////////////////// [003_POI][002_POI][001_POI]
                                                    // [003_POI][---=---][001_POI]
    console.log( "[_EVERYTHING_IS_OKAY_BABY_]" );   // [003_POI][002_POI][---=---]
                                                    // [---=---]
    //:#__ATOMIC_IVY_MMO_CONSTANTS__#:[23P]:=================://
                                                    //::[23P]://
        let c_sbx =( 640 ); //: @sbx@ : Sprite_Block.X :[23P]://
        let c_sby =( 896 ); //: @sby@ : Sprite_Block.Y :[23P]://
                                                    //::[---]://
        let c_tui_p2k =(0); //: $_TEX_UNI_IND_P2K_$   ::[24P]://
                                                    //::[---]://
        let c_clx =( 512 ); //: $_CENTER_LEVPACK_X_$  ::[31P]://
        let c_cly =( 512 ); //: $_CENTER_LEVPACK_Y_$  ::[31P]://
        let c_clw =( 512 ); //: $_CENTER_LEVPACK_W_$  ::[31P]://
        let c_clh =( 512 ); //: $_CENTER_LEVPACK_H_$  ::[31P]://
                                                    //::[---]://
        //:#_CAMERA_ARRAY_MEMBER_INDEXES_#:[39P]:------------://
                                //:                     [39P]://
            const   x_0 =( 0 ); //: Cam_Rect_Member.LEF [39P]://
            const   x_1 =( 1 ); //: Cam_Rect_Member.RIG [39P]://
            const   y_0 =( 2 ); //: Cam_Rect_Member.TOP [39P]://
            const   y_1 =( 3 ); //: Cam_Rect_Member.BOT [39P]://
                                //:                     [39P]://
        //:------------:#_CAMERA_ARRAY_MEMBER_INDEXES_#:[39P]://
        //:#_SPRITE_ATTRIBUTE_INDEXES_#:[35P]:---------------://
                                                    //::[35P]://
            const _sprite_attribute_indexes_=0 //:////::[35P]://
            ////                //:--------------:////::[35P]://
            ,   c_sai_gtx =( 1 )//: $_SAI_GTX_$ ::////::[35P]://
            ,   c_sai_gty =( 2 )//: $_SAI_GTY_$ ::////::[35P]://
            ////                //:             ::////::[35P]://
            ,   c_sai_dix =( 3 )//: $_SAI_DIX_$ ::////::[35P]://
            ,   c_sai_diy =( 4 )//: $_SAI_DIY_$ ::////::[35P]://
            ////                //:             ::////::[35P]://
            ,   c_sai_vel =( 5 )//: $_SAI_VEL_$ ::////::[35P]://
            ,   c_sai_acc =( 6 )//: $_SAI_ACC_$ ::////::[35P]://
            ,   c_sai_dra =( 7 )//: $_SAI_DRA_$ ::////::[35P]://
            ////                //:             ::////::[35P]://
            ,   c_sai_cx0 =( 8 )//: $_SAI_CX0_$ ::////::[35P]://
            ,   c_sai_cx1 =( 9 )//: $_SAI_CX1_$ ::////::[35P]://
            ,   c_sai_cy0 =(10 )//: $_SAI_CY0_$ ::////::[35P]://
            ,   c_sai_cy1 =(11 )//: $_SAI_CY1_$ ::////::[35P]://
            ////                //:             ::////::[35P]://
            ,   c_sai_hcx =(12 )//: $_SAI_HCX_$ ::////::[35P]://
            ,   c_sai_hcy =(13 )//: $_SAI_HCY_$ ::////::[35P]://
            ////                //:--------------:////::[35P]://
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//::[35P]://
        //:---------------:#_SPRITE_ATTRIBUTE_INDEXES_#:[35P]://
        //:#_TILE_DISCRETE_UNITS_#:[38P]:--------------------://
                                       //:              [38P]://
            const c_dum = 0x780000   ; //: THE_DUM      [38P]://
            const c_duh = 0x280000   ; //: HOTEL        [38P]://
            const c_dur = 0x080000   ; //: ROOM         [38P]://
            const c_dut = 0x002000   ; //: TILE         [38P]://
                                       //:              [38P]://
            const c_du0 = 0x002000   ; //: te7==0 (01_X)[38P]://
            const c_du1 = 0x004000   ; //: te7==1 (02_X)[38P]://
            const c_du2 = 0x008000   ; //: te7==2 (04_X)[38P]://
            const c_du3 = 0x010000   ; //: te7==3 (08_X)[38P]://
            const c_du4 = 0x020000   ; //: te7==4 (16_X)[38P]://
            const c_du5 = 0x040000   ; //: te7==5 (32_X)[38P]://
            const c_du6 = 0x080000   ; //: te7==6 (64_X)[38P]://
                                       //:              [38P]://
        //:--------------------:#_TILE_DISCRETE_UNITS_#:[38P]://
        //:#_DISCRETE_UNITS_CHARACTER_#:[44P]:---------------://
                                                    //::[44P]://
            const c_duc =( ( c_du0 | c_dut )>>>0 );;//::[44P]://
                                                    //::[44P]://
        //:---------------:#_DISCRETE_UNITS_CHARACTER_#:[44P]://
                                                    //::[---]://
    //:=================:#__ATOMIC_IVY_MMO_CONSTANTS__#:[23P]://
    //:#__ATOMIC_IVY_MMO_GLOBALS__#:[20P]:===================://
                                                    //::[20P]://
        let d_pix2048 ; //: $_CPU_PIX2048_AND_GPU_P2K_$ [20P]://
        /// d_p2k     ; //: @p2k@ ::::: Only In Shaders [20P]://
        let d_p2k_loc ; //: @p2k_loc@ : p2k's LOCATION  [20P]://
                                                    //::[20P]://
        let d_tik ; //: @tik@ : game TIcKer (game_time) [20P][MOV][19P]://
        let d_tik_loc ; //:@tik_loc@ : tik's LOCATION   [20P][MOV][19P]://
                                                    //::[---]://
        let d_sss     ; //: @sss@ : Sprite_Screen_Size  [36P]://
        let d_sss_loc ; //: @loc@ : LOCATION of "sss"   [36P]://
                                                    //::[---]://
        let d_vpc =( new Uint32Array(4));//:$_D_VPC_$   [37P]://
        let d_vp0 =( new Uint32Array(4));//:$_D_VP0_$   [37P]://
        let d_vp1 =( new Uint32Array(4));//:$_D_VP1_$   [37P]://
                                                    //::[---]://
        let d_vpc_loc ; //: Location : ViewPort_CANVAS  [37P]://
        let d_vp0_loc ; //: Location : ViewPort_DESTIN  [37P]://
        let d_vp1_loc ; //: Location : ViewPort_SOURCE  [37P]://
                                                    //::[---]://
    //:===================:#__ATOMIC_IVY_MMO_GLOBALS__#:[20P]://
    //:#__CONSTANTS__#:[26P]:================================://
                                                    //::        [26P]://
        let c_hack_cpu_texture =( 0 );              //::[37P]   [26P]://
                                                    //::[---]://
        let c_cmj =( c_dut *  1 );//: SEE[ $_C_M_JOT_$ ][64P]   [58P]://
        let c_cmz =( c_dum *  1 );//: SEE[ $_C_M_ZEN_$ ][64P]   [58P]://
        let c_cm0 =( c_dut * 22 );//: SEE[ $_C_M_NEU_$ ][64P]   [58P]://
                                                    //::[---]://
        let _bit_packed_glyphs_=(0)///////////////// //:[70P]://
        ,   c_l_0 =0x00000000 , c_r_0 =0x00000000    //:[70P]://
        ,   c_l_1 =0x00183818 , c_r_1 =0x18183C00    //:[70P]://
        ,   c_l_2 =0x007E4204 , c_r_2 =0x08307E00    //:[70P]://
        ,   c_l_3 =0x007E027E , c_r_3 =0x7E027E00    //:[70P]://
        ,   c_l_4 =0x00424242 , c_r_4 =0x7E020200    //:[70P]://
        ,   c_l_5 =0x007E407C , c_r_5 =0x02027C00    //:[70P]://
        ,   c_l_6 =0x007E4240 , c_r_6 =0x7E427E00    //:[70P]://
        ,   c_l_7 =0x007E0408 , c_r_7 =0x10101000    //:[70P]://
        ,   c_l_8 =0x007E427E , c_r_8 =0x42427E00    //:[70P]://
        ,   c_l_9 =0x007E427E , c_r_9 =0x02020200    //:[70P]://
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; //:[70P]://
                                                     //:[---]://
    //:================================:#__CONSTANTS__#:[26P]://
    //:#__GLOBALS__#:[004_POI]:==============================://
                                                    //::[---]://
        let d_ini ; //: @ini@ : Global - Initialized ?  [40P]://
                                                    //::[---]://
        let d_win ; //: @win@ : Global Window Object    [05P][004_POI]://
        let d_doc ; //: @doc@ : Global Document  OBJ    [07P]://
        let d_bod ; //: @bod@ : Global Document_Body    [07P]://
        let d_can ; //: @can@ : Global Canvas Object    [07P]://
        let d_wgl ; //: @wgl@ : Global WebGL  Context   [07P]://
        let d_wvc ; //: @wvc@ : Webgl_Version.CONTEXT   [07P]://
        let d_wvs ; //: @wvs@ : Webgl_Version.SHADER    [07P]://
                                                    //::[---]://
        let d_pmf ; //: @pmf@ : Precision_Medium_Float  [09P]://
        let d_sv1 ; //: @sv1@ : $_SRC_VERT_1_TILES_$    [09P]://
        let d_sf1 ; //: @sf1@ : $_SRC_FRAG_1_TILES_$    [09P]://
        let d_sv2 ; //: @sv2@ : $_SRC_VERT_2_POINT_$    [09P]://
        let d_sf2 ; //: @sf2@ : $_SRC_FRAG_2_POINT_$    [09P]://
                                                    //::[---]://
        let d_ver ; //: @ver@ : $_SYMBOLIC_CONST_V_$    [10P]://
        let d_fra ; //: @hor@ : $_SYMBOLIC_CONST_F_$    [10P]://
                                                    //::[---]://
        let d_ov1 ; //: @ov1@ : Object_VERT(shader)#1   [10P]://
        let d_of1 ; //: @of1@ : Object_FRAG(shader)#1   [10P]://
        let d_ov2 ; //: @ov2@ : Object_VERT(shader)#2   [10P]://
        let d_of2 ; //: @of2@ : Object_FRAG(shader)#2   [10P]://
                                                    //::[---]://    
        let d_hed ; //: @hed@ : shader HEaDer       //::[12P]://
                                                    //::[---]://
        let d_pid ; //: @pid@ : Program ID( object )    [13P]://
    let d_arr_pid ; //: @arr@ : ARRAY of ____ variable  [13P]://
                                                    //::[---]://
        let d_bytelen =( 2048 * 2048 * 4 );         //::[21P]://
        let d_p2k_tex ; //: d_p2k's texture handle    ::[22P]://
                                                    //::[---]://
        let d_marione =( 0 );//: $_MARIONETTE_$ :// //::[29P]://
        let d_orx     =( 0 );//: $_OFFSETRAWX_$ :// //::[29P]://
        let d_ory     =( 0 );//: $_OFFSETRAWY_$ :// //::[29P]://
                                                    //::[---]://
        let d_poi_vpc =( "[_CPU_SIDE_IS_:d_vpc]" ); //::[41P]://
        let d_poi_vp0 =( "[_CPU_SIDE_IS_:d_vp0]" ); //::[41P]://
        let d_poi_vp1 =( "[_CPU_SIDE_IS_:d_vp1]" ); //::[41P]://
                                                    //::[---]://
        let d_cdx ; //: @cdx@ : Camera_Discrete_X       [57P]://
        let d_cdy ; //: @cdy@ : Camera_Discrete_Y       [57P]://
        let d_czp ; //: @czp@ : Camera_Zoom_Percent     [57P]://
        let d_cm0 ; //: @cm0@ : Camera_Marion #0 (FROM) [57P]://
        let d_cm1 ; //: @cm1@ : Camera_Marion #1 (_TO_) [57P]://
        let d_cmp ; //: @cmp@ : Camera_Marion_Percent   [57P]://
        let d_cma ; //: @cma@ : Camera_Marion_Animate?  [57P]://
                                                    //::[---]://
    //:==============================:#__GLOBALS__#:[004_POI]://
    //:#__ERROR__#:[08P]:====================================://
    let F_ERROR =(   i_msg )=>{                      //:[08P]://
        d_win.alert( i_msg );                        //:[08P]://
        throw(       i_msg );                        //:[08P]://
    };;                                              //:[08P]://
    //:====================================:#__ERROR__#:[08P]://
    //:#__MAX__#:[64P]:======================================://
    let F_MAX =( i_val_001 , i_val_002 )=>{          //:[64P]://
                                                     //:[64P]://
        let o_val =( i_val_001 > i_val_002 ?    //// //:[64P]://
                     i_val_001 : i_val_002 );;;;;;;; //:[64P]://
        return( o_val );;;;;;;;;;;;;;;;;;;;;;;;;;;;; //:[64P]://
    };;                                              //:[64P]://
    //:======================================:#__MAX__#:[64P]://
    //:#__PUT_SPRITE_PROPERTY_VALUE__#:[58P]:================://
    let F_PUT_SPRITE_PROPERTY_VALUE =(              //::[58P]://
                                                    //::[58P]://
        i_m64 //: @i_m64@ : INN - Marionette Index      [58P]://
    ,   i_sai //: @i_sai@ : Sprite attrib index         [58P]://
    ,   i_u32 //: @i_u32@ : INN - Uint32 Value          [58P]://
                                                    //::[58P]://
    )=>{                                            //::[58P]://
                                                    //::[---]://
        const s_m =( d_pix2048 );//:@s_m@:SpriteMemory  [60P]://
                                                    //::[60P]://
        let dpx ; //: @dpx@ : Data_Pixel_X ( X_AXIS  )  [60P]://
        let dpy ; //: @dpy@ : Data_Pixel_Y ( Y_AXIS  )  [60P]://
        let dpi ; //: @dpi@ : Data_Pixel_I ( I:INDEX )  [60P]://
        let dpc ; //: @dpc@ : Data_Pixel_C ( C:COMPO )  [60P]://
                                                    //::[60P]://
            dpx =( c_sbx + i_m64 );;;;;;;;;;        //::[60P]://
            dpy =( c_sby + i_sai );;;;;;;;;;        //::[60P]://
                                                    //::[60P]://
            dpi =( dpx + ( dpy * 2048 ) );;;        //::[60P]://
            dpc =( dpi * 4 );;;;;;;;;;;;;;;;        //::[60P]://
                                                    //::[60P]://
            const u=( i_u32 ); //: $_SAVE_COLUMNS_$   ::[60P]://
            s_m[ dpc+0 ]=((( u>>> 24 ) & 0xFF)>>>0);//::[60P]://
            s_m[ dpc+1 ]=((( u>>> 16 ) & 0xFF)>>>0);//::[60P]://
            s_m[ dpc+2 ]=((( u>>>  8 ) & 0xFF)>>>0);//::[60P]://
            s_m[ dpc+3 ]=((( u>>>  0 ) & 0xFF)>>>0);//::[60P]://
                                                    //::[60P]://
        return; /** RETURN_VOID **/                 //::[60P]://
                                                    //::[---]://
    };;                                             //::[58P]://
    //:================:#__PUT_SPRITE_PROPERTY_VALUE__#:[58P]://
    //:#__GET_SPRITE_PROPERTY_VALUE__#:[58P]:================://
    let F_GET_SPRITE_PROPERTY_VALUE =(              //::[58P]://
                                                    //::[58P]://
        i_m64 //: @i_m64@ : INN - Marionette Index      [58P]://
    ,   i_sai //: @i_sai@ : Sprite attrib index         [58P]://
                                                    //::[58P]://
    )=>{                                            //::[58P]://
                                                    //::[---]://
        const s_m =( d_pix2048 );//:@s_m@:SpriteMemory  [59P]://
                                                    //::[59P]://
        let dpx ; //: @dpx@ : Data_Pixel_X ( X_AXIS  )  [59P]://
        let dpy ; //: @dpy@ : Data_Pixel_Y ( Y_AXIS  )  [59P]://
        let dpi ; //: @dpi@ : Data_Pixel_I ( I:INDEX )  [59P]://
        let dpc ; //: @dpc@ : Data_Pixel_C ( C:COMPO )  [59P]://
                                                    //::[59P]://
            dpx =( c_sbx + i_m64 );;;;;;;;;;        //::[59P]://
            dpy =( c_sby + i_sai );;;;;;;;;;        //::[59P]://
                                                    //::[59P]://
            dpi =( dpx + ( dpy * 2048 ) );;;        //::[59P]://
            dpc =( dpi * 4 );;;;;;;;;;;;;;;;        //::[59P]://
                                                    //::[59P]://
        let o_u32=((0x0                             //::[59P]://
            |   ( ( s_m[ dpc+0 ] ) << 24 )//        //::[59P]://
            |   ( ( s_m[ dpc+1 ] ) << 16 )//        //::[59P]://
            |   ( ( s_m[ dpc+2 ] ) <<  8 )//        //::[59P]://
            |   ( ( s_m[ dpc+3 ] ) <<  0 )//        //::[59P]://
        )>>>0);;;;;;;;;;;;;;;;;;;;;;;;;;;;//        //::[59P]://
                                                    //::[59P]://
        return( o_u32 );                            //::[59P]://
                                                    //::[---]://
    };;                                             //::[58P]://
    //:================:#__GET_SPRITE_PROPERTY_VALUE__#:[58P]://
    //:#__PLAYER_CONTROL__#:[20P]:===========================://
    let F_PLAYER_CONTROL =( i_kev )=>{               //:[20P]://
                                                    //::[---]://
        let key =( i_kev.key  ||  "" );             //::[29P]://
            key =( key.toUpperCase() );             //::[29P]://
                                                    //::[29P]://
        //:- - - - - - - - - - - - - - - - - - -:// //::[29P]://
        //:hunterxhunter.fandom.com/wiki/Marione:// //::[29P]://
        //:- - - - - - - - - - - - - - - - - - -:// //::[29P]://
                                                    //::[29P]://
        //:#__CHOOSE_PLAYER__#:[29P]:------------------------://
                                                    //::[29P]://
        if( "0" === key ){ d_marione =( 0 ); };     //::[29P]://
        if( "1" === key ){ d_marione =( 1 ); };     //::[29P]://
        if( "2" === key ){ d_marione =( 2 ); };     //::[29P]://
        if( "3" === key ){ d_marione =( 3 ); };     //::[29P]://
        if( "4" === key ){ d_marione =( 4 ); };     //::[29P]://
        if( "5" === key ){ d_marione =( 5 ); };     //::[29P]://
        if( "6" === key ){ d_marione =( 6 ); };     //::[29P]://
        if( "7" === key ){ d_marione =( 7 ); };     //::[29P]://
        if( "8" === key ){ d_marione =( 8 ); };     //::[29P]://
        if( "9" === key ){ d_marione =( 9 ); };     //::[29P]://
                                                    //::[29P]://
        //:------------------------:#__CHOOSE_PLAYER__#:[29P]://
        //:#__PLAYER_OFFSET_RAW__#:[29P]:--------------------://
                                                    //::[29P]://
            d_orx =( 0 ); //: @orx@ : Offset_Raw_X      [29P]://
            d_ory =( 0 ); //: @ory@ : Offset_Raw_Y      [29P]://
                                                    //::[29P]://
            if( i_kev.keyCode === ( 37           )  //::[29P]://
            ||  i_kev.key     === ( "ARROWLEFT"  )  //::[29P]://
            ){                                      //::[29P]://
                d_orx =( 0-1 );                     //::[29P]://
            }else                                   //::[29P]://
            if( i_kev.keyCode === ( 38           )  //::[29P]://
            ||  i_kev.key     === ( "ARROWUP"    )  //::[29P]://
            ){                                      //::[29P]://
                d_ory =( 0-1 );                     //::[29P]://
            }else                                   //::[29P]://
            if( i_kev.keyCode === ( 39           )  //::[29P]://
            ||  i_kev.key     === ( "ARROWRIGHT" )  //::[29P]://
            ){                                      //::[29P]://
                d_orx =( 0+1 );                     //::[29P]://
            }else                                   //::[29P]://
            if( i_kev.keyCode === ( 40           )  //::[29P]://
            ||  i_kev.key     === ( "ARROWDOWN"  )  //::[29P]://
            ){                                      //::[29P]://
                d_ory =( 0+1 );                     //::[29P]://
            };;                                     //::[29P]://
        //:--------------------:#__PLAYER_OFFSET_RAW__#:[29P]://
        //:#_CPU_UPDATE_PLAYER_#:[30P]:----------------------://
                                                    //::[30P]://
            //:- - - - - - - - - - - -- - - - - - - - - - - -://
            //: @s_m@   : Sprite_Memory           ::::::[30P]://
            //: @sac_x@ : SpriteAttributeColumn.X ::::::[30P]://
            //: @sac_y@ : SpriteAttributeColumn.Y ::::::[30P]://
            //: @sac_i@ : SpriteAttributeColumn.I ::::::[30P]://
            //: @sai@   : SpriteAttribute___INDEX ::::::[30P]://
            //: @sav@   : SpriteAttribute___VALUE ::::::[30P]://
            //:                                         [30P]://
            //: @dpi@   : Data_Pixel's INDEX Location   [30P]://
            //: @dpc@   : Data_Pixel's COMPONENT  Loc   [30P]://
            //:                                         [30P]://
            //: @d_x@   : Delta_X To Apply To Sprite POS[30P]://
            //: @d_y@   : Delta_Y To Apply To Sprite POS[30P]://
            //:- - - - - - - - - - - -- - - - - - - - - - - -://
                                                    //::[30P]://
            let s_m   =( d_pix2048 );;;;;;;;;;;;;;;;//::[30P]://
            let sac_x =( c_sbx + d_marione        );//::[30P]://
            let sac_y =( c_sby                    );//::[30P]://
            let sac_i =( sac_x + ( sac_y * 2048 ) );//::[30P]://
            let sai ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//::[30P]://
            let sav ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//::[30P]://
                                                    //::[30P]://
            let dpi ; //: @dpi@ : DataPixelIndex :////::[30P]://
            let dpc ; //: @dpc@ : DataPixelCompo :////::[30P]://
                                                    //::[30P]://
            //: $_NO_MORE_DELTA_XY_$ ://            //::[67P]   [REM][30P]://
                                                    //::[---]://
            for( sai = 1 ; sai <=( 2 ) ; sai ++ ){  //::[30P]://
                                                    //::[30P]://
                dpi =( sac_i + (2048*sai) );        //::[30P]://
                dpc =( dpi * 4 );                   //::[30P]://
                                                    //::[30P]://
                sav=( ( 0x00000000 )                //::[---]    [---][30P]://
                |   ( ( s_m[ dpc+0 ] )<< 24)        //::[33P]    [BUG][30P]://
                |   ( ( s_m[ dpc+1 ] )<< 16)        //::[33P]    [BUG][30P]://
                |   ( ( s_m[ dpc+2 ] )<<  8)        //::[33P]    [BUG][30P]://
                |   ( ( s_m[ dpc+3 ] )<<  0)        //::[33P]    [BUG][30P]://
                )>>>0 ;;;;;;;;;;;;;;;;;;;;;;        //::[---]    [---][30P]://
                                                    //::[30P]://
                if( 1 === sai ){ sav += d_orx };    //::[67P]    [30P]://
                if( 2 === sai ){ sav += d_ory };    //::[67P]    [30P]://
                                                    //::[30P]://
                //:SEE[ $_BYTE_EXTRACTION_LOGIC_$ ]:::::[30P]://
                //:SEE[ $_BEL_LOGIC_DOUBLE_CHEK_$ ]:::::[33P]://
                                                    //::[30P]://
                s_m[ dpc + 0 ]=(sav & 0xFF000000)>>>24 ;//:30://
                s_m[ dpc + 1 ]=(sav & 0x00FF0000)>>>16 ;//:30://
                s_m[ dpc + 2 ]=(sav & 0x0000FF00)>>> 8 ;//:30://
                s_m[ dpc + 3 ]=(sav & 0x000000FF)>>> 0 ;//:30://
                                                    //::[30P]://
            };;//:NEXT[ sai ]:::::::::::::::::::::::::::[30P]://
        //:----------------------:#_CPU_UPDATE_PLAYER_#:[30P]://  
        //:#_GPU_UPDATE_PLAYER_#:[31P]:----------------------://
        {   //:- - - - - - - - - - - -- - - - - - - - - - - -://                               
            //: @oib2048@ : Offset_In_Bytes : pix2048 ::[31P]://
            //: @symname@ : Symbolic_Name  :::::::::::::[31P]://
            //: @symvalu@ : Symbolic_Value :::::::::::::[31P]://
            //:- - - - - - - - - - - -- - - - - - - - - - - -://   
                                                     //:[31P]://
            let oib2048 =( 4*( c_clx+(c_cly*2048)) );//:[31P]://
            let symname =( d_wgl.UNPACK_ROW_LENGTH );//:[31P]://
            let symvalu =( 2048 );;;;;;;;;;;;;;;;;;;;//:[31P]://             
                                                    //::[31P]://
            d_wgl.pixelStorei( symname , symvalu );;//::[31P]://                                                 
            d_wgl.texSubImage2D(//::::::::::::::[ S_T_P_M_B ]://
                                //:                     [31P]://
                d_wgl.TEXTURE_2D//:TARGET               [31P]://
            ,     0             //:LEVEL ( @L_O_D@ )    [31P]://
                                //:                     [31P]://
            ,   c_clx , c_cly   //: $_CLP_ORG_$         [31P]://
            ,   c_clw , c_clh   //: $_CLP_MAG_$         [31P]://
                                //:                     [31P]://
                //:---------------------------------:   [31P]://
            ,   d_wgl.RGBA_INTEGER  //: $_SRC_FMT_$ :   [31P]://
            ,   d_wgl.UNSIGNED_BYTE //: $_SRC_TYP_$ :   [31P]://
                //:---------------------------------:   [31P]://
                            //:                         [31P]://
            ,   d_pix2048   //: ARRAY_BUFFER_VIEW       [31P]://
            ,     oib2048   //: SOURCE_OFFSET           [31P]://
            //:_________________________________________[31P]://
            );;//:::::::::::::::::::::::::::::::[ S_T_P_M_B ]://                    
        }                                           //::[31P]://
        //:----------------------:#_GPU_UPDATE_PLAYER_#:[31P]://
                                                    //::[---]://
    };;                                             //::[20P]://
    //:===========================:#__PLAYER_CONTROL__#:[20P]://
    //:#__CAMERA_CONTROL__#:[39P]:===========================://
    let F_CAMERA_CONTROL =( i_kev )=>{              //::[39P]://
                                                    //::[39P]://
        let key =( i_kev.key  ||  "" );             //::[39P]://
            key =( key.toUpperCase() );             //::[39P]://
                                                    //::[39P]://
        if( "_" === key || "-" === key ){           //::[39P]://
                                                    //::[39P]://
            console.log( "[_ZOOM_OUT_]" );          //::[39P]://
            ( d_vp1[ x_0 ] ) -= ( c_dut );          //::[55P]   [39P]://
            ( d_vp1[ x_1 ] ) += ( c_dut );          //::[55P]   [39P]://
            ( d_vp1[ y_0 ] ) -= ( c_dut );          //::[55P]   [39P]://
            ( d_vp1[ y_1 ] ) += ( c_dut );          //::[55P]   [39P]://
        }else                                       //::[39P]://
        if( "=" === key || "+" === key ){           //::[39P]://
                                                    //::[39P]://
            console.log( "[_ZOOM_INN_]" );          //::[39P]://
            ( d_vp1[ x_0 ] ) += ( c_dut );          //::[55P]   [39P]://
            ( d_vp1[ x_1 ] ) -= ( c_dut );          //::[55P]   [39P]://
            ( d_vp1[ y_0 ] ) += ( c_dut );          //::[55P]   [39P]://
            ( d_vp1[ y_1 ] ) -= ( c_dut );          //::[55P]   [39P]://
        };;                                         //::[39P]://
    };;                                             //::[39P]://
    //:===========================:#__CAMERA_CONTROL__#:[39P]://
    //:#__KEYBOARD_CONTROL__#:[39P]:=========================://
    let F_KEYBOARD_CONTROL =( i_kev )=>{            //::[39P]://
                                                    //::[39P]://
        F_PLAYER_CONTROL( i_kev );                  //::[39P]://
        F_CAMERA_CONTROL( i_kev );                  //::[39P]://
    };;                                             //::[39P]://
    //:=========================:#__KEYBOARD_CONTROL__#:[39P]://
    //:#__COMPILE_SHADER__#:[11P]:===========================://
    let F_COMPILE_SHADER =( i_wso )=>{               //:[11P]://
                                                     //:[11P]://
        let sym =( d_wgl.COMPILE_STATUS );           //:[11P]://
        let bol =( false );;;;;;;;;;;;;;;;           //:[11P]://
        let str =( null  );;;;;;;;;;;;;;;;           //:[11P]://
                                                     //:[11P]://
               d_wgl.compileShader(     i_wso     );;//:[11P]://
        bol =( d_wgl.getShaderParameter(i_wso,sym));;//:[11P]://
                                                     //:[11P]://
        if( ! bol ){                                 //:[11P]://
            str =(d_wgl.getShaderInfoLog(   i_wso ));//:[11P]://
            console.log( "[_FAIL_LOG_:STR]:" , str );//:[11P]://
            F_ERROR(     "[_$_UR_SHADER_SUCKS_$_]" );//:[11P]://
        };;                                          //:[11P]://
    };;                                              //:[11P]://
    //:===========================:#__COMPILE_SHADER__#:[11P]://
    //:#__RESIZE_CANVAS__#:[40P]:============================://
    let F_RESIZE_CANVAS =( )=>{                     //::[40P]://
                                                    //::[40P]://
        if( ! d_can ){ F_ERROR( "[_$_NCE_$_]" ); }; //::[40P]://
                                                    //::[40P]://
        let wid ; //: width  of the client area :// //::[40P]://
        let hig ; //: height of the client area :// //::[40P]://
                                                    //::[---]://
        let _c_=( d_vpc );;;;;;;;;;;;;;;;;;;;;;;    //::[54P]   [MOV][40P]://
        let _0_=( d_vp0 );;;;;;;;;;;;;;;;;;;;;;;    //::[54P]   [MOV][40P]://
                                                    //::[---]://
        if( 1 === 1 ){  //:::::::::::::::::::[_CAN_MAG_][40P]://
                                                    //::[40P]://
            let d_e =( d_doc.documentElement );     //::[40P]://
                wid =( d_e.clientWidth       );     //::[42P]   [BUG][40P]://
                hig =( d_e.clientHeight      );     //::[42P]   [BUG][40P]://
                                                    //::[40P]://
            d_can.width =( wid );                   //::[40P]://
            d_can.height=( hig );                   //::[40P]://
                                                    //::[---]://
            //:#__SNAP_VPC_TO_CLIENT__#:[54P]:---------------://
                _c_[ x_0 ]=( 0 );;;;;;;;            //::[54P]   [MOV][40P]://
                _c_[ y_0 ]=( 0 );;;;;;;;            //::[54P]   [MOV][40P]://
                _c_[ x_1 ]=( wid - 1 );;//: $_IREC_$    [54P]   [MOV][40P]://
                _c_[ y_1 ]=( hig - 1 );;//: $_IREC_$    [54P]   [MOV][40P]://
            //:---------------:#__SNAP_VPC_TO_CLIENT__#:[54P]://
            //:#__SNAP_VP0_ONTO_VPC__#:[54P]:----------------:::[MOV][40P]://
                                                    //::[54P]   [MOV][40P]://
                _0_[ x_0 ]=( _c_[ x_0 ] );          //::[54P]   [MOV][40P]://
                _0_[ y_0 ]=( _c_[ y_0 ] );          //::[54P]   [MOV][40P]://
                _0_[ x_1 ]=( _c_[ x_1 ] );          //::[54P]   [MOV][40P]://
                _0_[ y_1 ]=( _c_[ y_1 ] );          //::[54P]   [MOV][40P]://
                                                    //::[54P]   [MOV][40P]://
            //:----------------:#__SNAP_VP0_ONTO_VPC__#:[54P]:::[MOV][40P]://
                                                    //::[---]://
        };;;//:::::::::::::::::::::::::::::::[_CAN_MAG_][40P]://
        if( d_ini <= 0 ){ //:::::::::::::::::[_INI_CAM_][42P]://
                                                    //::[42P]://
            //:#__SNAP_TO_CENTER_____HOTEL_#:[42P]:----------://
            //:#__SNAP_TO_CENTER_LEVELPACK_#:[42P]:----------://
            let _1_=( d_vp1 );                      //::[42P]://
                _1_[ x_0 ]=( c_duh +( 0x0000000 ) );//::[42P]://
                _1_[ y_0 ]=( c_duh +( 0x0000000 ) );//::[42P]://
                _1_[ x_1 ]=( c_duh +( c_duh - 1 ) );//::[42P]://
                _1_[ y_1 ]=( c_duh +( c_duh - 1 ) );//::[51P]   [BUG][42P]://
                                                    //::[42P]://
            //:----------:#__SNAP_TO_CENTER_LEVELPACK_#:[42P]://
            //:----------:#__SNAP_TO_CENTER_____HOTEL_#:[42P]://
                                                    //::[42P]://
        }else   //:::::::::::::::::::::::::::[_INI_CAM_][42P]://
        if( d_ini >= 1 ){ //:::::::::::::::::[_VPC_VP0_][40P]://
                                                    //::[---]://
            //:$_A_HOLE_WHERE_MY_CODE_USED_TO_BE_$      [54P]://
                                                    //::[---]://
            d_wgl.viewport(                         //::[40P]://
                ( _c_[ x_0 ]               ) //:_org_x_:[40P]://
            ,   ( _c_[ y_0 ]               ) //:_org_y_:[40P]://
            ,   ( _c_[ x_1 ]- _c_[ x_0 ]+1 ) //:_v_wid_:[40P]://
            ,   ( _c_[ y_1 ]- _c_[ y_0 ]+1 ) //:_v_hig_:[40P]://
            );;                                     //::[40P]://
                                                    //::[---]://
            //:$_A_HOLE_WHERE_MY_CODE_USED_TO_BE_$      [54P]://
                                                    //::[---]://
            /** TODO : Letter Box Inset **/         //::[40P]://
                                                    //::[40P]://
        }else{  //:::::::::::::::::::::::::::[_VPC_VP0_][51P]   [40P]://
        //:::::::::::::::::::::::::::::::::::[_INI_WTF_][51P]://
                                                     //:[51P]://
            F_ERROR( "[_INI_WTF_]" );                //:[51P]://
                                                     //:[51P]://
        //:::::::::::::::::::::::::::::::::::[_INI_WTF_][51P]://
        };; //:::::::::::::::::::::::::::::::[_INI_WTF_][51P]://
                                                    //::[40P]://
    };;                                             //::[40P]://
    //:============================:#__RESIZE_CANVAS__#:[40P]://
    //:#__SETUP__#:[05P]:====================================://
    let F_SETUP =( )=>{                             //::[05P]://
                                                    //::[---]://
        //:#__NOT_SETUP_YET__#:[40P]:-----------:// //::[40P]://
                                                    //::[40P]://
            d_ini =( 0 ); /** Setup/Initialized **/ //::[40P]://
                                                    //::[40P]://
        //:-----------:#__NOT_SETUP_YET__#:[40P]:// //::[40P]://
                                                    //::[---]://
        d_win =( window               );;;;;;;;;;;; //::[05P]://
        d_doc =( window.document      );;;;;;;;;;;; //::[07P]://
                                                    //::[07P]://
        d_can =( d_doc.createElement( "canvas" ) ); //::[08P][MOV][07P]://
        d_bod =( d_doc.createElement( "body"   ) ); //::[08P]://
        d_doc.body =( d_bod );                      //::[08P]://
        if( d_bod != window.document.body ){        //::[08P]://
            F_ERROR( "[_BODY_ERROR_]" );            //::[08P]://
        };;                                         //::[08P]://
                                                    //::[---]://
        //:#_REMOVE_SCROLL_BARS_#:[56P]:---------------------://
        {                                           //::[56P]://
            let b_s =( d_bod.style );               //::[56P]://
                b_s.padding  = "0"     ;            //::[56P]://
                b_s.margin   = "0"     ;            //::[56P]://
                b_s.overflow = "hidden";            //::[56P]://
                b_s.scroll   = "no"    ;//:IE_ONLY:////:[56P]://
        }                                           //::[56P]://
        //:---------------------:#_REMOVE_SCROLL_BARS_#:[56P]://
                                                    //::[---]://
        //- d_can.width=(  512 );;;; -//            //::[40P]   [07P]://
        //- d_can.height=( 512 );;;; -//            //::[40P]   [07P]://
                                                    //::[---]://
        F_RESIZE_CANVAS( );                         //::[40P]://
                                                    //::[---]://
        d_bod.appendChild( d_can );;;;;;;;;;;;;;;;; //::[07P]://
                                                    //::[07P]://
        d_wvc =( "webgl2"                  );;;;;;; //::[07P]://
        d_wvs =( "#version 300 es"         );;;;;;; //::[07P]://
        d_wgl =( d_can.getContext( d_wvc ) );;;;;;; //::[07P]://
        d_pmf =( "precision mediump float" );;;;;;; //::[09P]://
                                                    //::[---]://
        d_hed =( d_wvs  +  "\n"  +  d_pmf + ";" );; //::[12P]://
                                                    //::[---]://
        //:#__IAM_A_DIRTY_LIAR__#:[14P]:--------:// //::[14P]://
        d_sv1 =(d_hed)+(`                           //::[14P][09P]://
                                                    //::[---]://
          #define I_D ( gl_VertexID )               //::[15P]://
          #define F32 float                         //::[15P]://
                                                    //::[15P]://
            //:$_CAP_N_DIA_$:[15P]:-------------:// //::[15P]://
                                                    //::[15P]://
                const int v_x[4]=int[4]( 0,0,1,1 ); //::[15P]://
                const int v_y[4]=int[4]( 0,1,0,1 ); //::[15P]://
                                                    //::[15P]://
            //:-------------:$_CAP_N_DIA_$:[15P]:// //::[15P]://
                                                    //::[15P]://
            void main( ){   //::::::::[_v1main_]:// //::[---][14P]://
                                                    //::[15P]://
                gl_Position = vec4(                 //::[15P]://
                                                    //::[15P]://
                    1.0 -( F32( v_x[ I_D ] ) * 2.0 )//::[15P]://
                ,   1.0 -( F32( v_y[ I_D ] ) * 2.0 )//::[15P]://
                ,   0.0                             //::[15P]://
                ,   1.0                             //::[15P]://
                );;                                 //::[15P]://
                                                    //::[---]://
            }/////////////////////////[_v1main_]:// //::[14P]://
        `);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; //::[14P][09P]://
        //:--------:#__IAM_A_DIRTY_LIAR__#:[14P]:// //::[14P]://
                                                    //::[---]://
        //:#__MAP_RENDERER_FRAG__#:[45P]:--------------------://
                                                    //::[---]://
        d_sf1 =(d_hed)+(`                           //::[12P][09P]://
                                                    //::[---]://
            out vec4 f_c ;//: $_GL_FRAG_COLOR_$ :// //::[12P]://
                                                    //::[---]://
            #define I32 int     //: $_OCD_I32_$ :// //::[16P]://
            #define U32 uint    //: $_OCD_U32_$ :// //::[16P]://
            #define UV4 uvec4   //: $_OCD_UV4_$ :// //::[37P]://
            #define UV2 uvec2   //: $_OCD_UV2_$ :// //::[46P]://
            #define FV2  vec2   //: $_OCD_FV2_$ :// //::[53P]://
            #define FV4  vec4   //: $_OCD_FV4_$ :// //::[53P]://
                                                    //::[---]://
            #define x_0  ( uint( ${   x_0 } ) )     //::[46P]://
            #define x_1  ( uint( ${   x_1 } ) )     //::[46P]://
            #define y_0  ( uint( ${   y_0 } ) )     //::[46P]://
            #define y_1  ( uint( ${   y_1 } ) )     //::[46P]://
                                                    //::[---]://
            #define u_1   ( uint(      0x1 )  )     //::[46P]://
            #define u_000 ( uint(      0x0 )  )     //::[52P]://
            #define u_320 ( uint(      320 )  )     //::[52P]://
            #define u_639 ( uint(      639 )  )     //::[054]://
            #define u_959 ( uint(      959 )  )     //::[52P]://
            #define u_960 ( uint(      960 )  )     //::[52P]://
                                                    //::[---]://
            #define DUT  ( uint( ${ c_dut } ) )     //::[50P]://
            #define DUR  ( uint( ${ c_dur } ) )     //::[50P]://
            #define DUH  ( uint( ${ c_duh } ) )     //::[50P]://
                                                    //::[---]://
            #define GREY_DARK  vec4(0.2,0.2,0.2,1)  //::[16P]://
            #define GREY_LIGHT vec4(0.8,0.8,0.8,1)  //::[16P]://
                                                    //::[16P]://
            #define IFX ( int( gl_FragCoord.x ) )   //::[16P]://
            #define IFY ( int( gl_FragCoord.y ) )   //::[16P]://
            #define GFC (      gl_FragCoord     )   //::[49P]://
                                                    //::[---]://
            uniform UV4 d_vpc ; //:$_TILEMAP_VPC_$      [37P]://
            uniform UV4 d_vp0 ; //:$_TILEMAP_VP0_$      [37P]://
            uniform UV4 d_vp1 ; //:$_TILEMAP_VP1_$      [37P]://
                                                    //::[---]://
            //:#_FOR_RENDERING_TILE_GTX_GTY_#:[70P]:---------://
            U32 n10_u32[20]=U32[20](                 //:[70P]://
                                                     //:[70P]://
               U32( ${ c_l_0 } ) , U32( ${ c_r_0 } ) //:[70P]://
            ,  U32( ${ c_l_1 } ) , U32( ${ c_r_1 } ) //:[70P]://
            ,  U32( ${ c_l_2 } ) , U32( ${ c_r_2 } ) //:[70P]://
            ,  U32( ${ c_l_3 } ) , U32( ${ c_r_3 } ) //:[70P]://
            ,  U32( ${ c_l_4 } ) , U32( ${ c_r_4 } ) //:[70P]://
            ,  U32( ${ c_l_5 } ) , U32( ${ c_r_5 } ) //:[70P]://
            ,  U32( ${ c_l_6 } ) , U32( ${ c_r_6 } ) //:[70P]://
            ,  U32( ${ c_l_7 } ) , U32( ${ c_r_7 } ) //:[70P]://
            ,  U32( ${ c_l_8 } ) , U32( ${ c_r_8 } ) //:[70P]://
            ,  U32( ${ c_l_9 } ) , U32( ${ c_r_9 } ) //:[70P]://
            );                                       //:[70P]://
            //:---------:#_FOR_RENDERING_TILE_GTX_GTY_#:[70P]://
                                                    //::[---]://
            void main( ){   //::::::::[_f1main_]:// //::[09P]://
                                                    //::[---]://
                U32 t_x ; //: @t_x@ : Tile Cell X       [50P]   [16P]://
                U32 t_y ; //: @t_y@ : Tile Cell Y       [50P]   [16P]://
                                                    //::[16P]://
                U32 o_x ; //: @o_x@ : ODD__Cell X ?     [45P]   [BUG][16P]://
                U32 o_y ; //: @o_y@ : ODD__Cell Y ?     [45P]   [BUG][16P]://
                                                    //::[---]://
                FV2 mv0 ; //: Magnitude_of[__vp0__]     [53P]   [46P]://
                FV2 mv1 ; //: Magnitude_of[__vp1__]     [53P]   [46P]://
                FV2 duf ; //: Discrete_Units_Per_Frag   [53P]   [46P]://
                                                    //::[---]://
                FV2 vfc ; //: Viewport(local)FragCoord  [49P]://
                          //: $_DIAGRAM_VFC_$ ::::::::::[49P]://
                                                    //::[---]://
                UV2 dug ; //: Discrete_Unit_Global      [50P]://
                                                    //::[---]://
                //:#_GET_DUG_#:[47P]:------------------------://
                #define _0 d_vp0  //:DESTIN_AKA_SCREEN::[   ]   [47P]://
                #define _1 d_vp1  //:SOURCE_TILE_DATA ::[   ]   [47P]://
                                                    //::[   ]   [47P]://
                    mv0 =FV2(_0[x_1]-_0[x_0]+u_1    //::[53P]   [47P]://
                        ,    _0[y_1]-_0[y_0]+u_1 );;//::[   ]   [47P]://
                    mv1 =FV2(_1[x_1]-_1[x_0]+u_1    //::[53P]   [47P]://
                        ,    _1[y_1]-_1[y_0]+u_1 );;//::[   ]   [47P]://
                                                    //::[   ]   [47P]://
                //::: $_DUF_E__MV1_D_MV0_$ :::::::::::::[   ]   [48P]://
                        duf =( mv1 / mv0 );;;;;;    //::[   ]   [48P]://
                                                    //::[   ]   [---]://
                    vfc=( FV2(  //: $_DIA_VFC_$ :// //::[   ]   [49P]://
                     U32( GFC.x - 0.5 )-_0[x_0]     //::[   ]   [49P]://
                    ,U32( GFC.y - 0.5 )-_0[y_0] ));;//::[   ]   [49P]://
                                                    //::[   ]   [---]://
                    dug=( UV2(  ////////////////    //::[   ]   [50P]://
                     d_vp1[x_0]+U32(vfc.x*duf.x)    //::[53P]   [50P]://
                    ,d_vp1[y_0]+U32(vfc.y*duf.y)    //::[53P]   [50P]://
                    ));;;;;;;;;;;;;;;;;;;;;;;;;;    //::[   ]   [50P]://
                                                    //::[   ]   [---]://
                #undef  _1                          //::[   ]   [47P]://
                #undef  _0                          //::[   ]   [47P]://
                //:------------------------:#_GET_DUG_#:[   ]   [47P]://
                                                    //::[---]://
                t_x =( dug.x / DUT );               //::[50P]   [16P]://
                t_y =( dug.y / DUT );               //::[50P]   [16P]://
                                                    //::[16P]://
                o_x =( U32(t_x) & U32(1) );//:$_BOARD_$ [45P]   [BUG][16P]://
                o_y =( U32(t_y) & U32(1) );//:$_BOARD_$ [45P]   [BUG][16P]://
                                                    //::[16P]://
                if( o_x == o_y ){                   //::[45P]   [BUG][16P]://
                    f_c =( GREY_DARK  );            //::[16P]://
                }else{                              //::[16P]://
                    f_c =( GREY_LIGHT );            //::[16P]://
                };;                                 //::[16P]://
                                                    //::[---]://
                //:#_LINE_DEBUG_HACK_#:[52P]:----------------://
                if( 1==1 ){                         //::[---]   [52P]://
                    //: HOR_RED ==> CORNER_RED          [54P]   [52P]://
                    if(t_x ==u_320 && t_y ==u_320){ //::[54P]   [52P]://
                       f_c =( vec4( 1,0,0, 1.0 ) ); //::[---]   [52P]://
                    };;                             //::[---]   [52P]://
                                                    //::[---]   [52P]://
                    //: VER_BLU ==> CORNER_BLU          [54P]   [52P]://
                    if(t_x ==u_639 && t_y ==u_639){ //::[54P]   [52P]://
                       f_c =( vec4( 0,0,1, 1.0 ) ); //::[---]   [52P]://
                    };;                             //::[---]   [52P]://
                                                    //::[---]://
                    if( d_vp1[x_0] !=( DUH         )//::[53P]://
                    ||  d_vp1[y_0] !=( DUH         )//::[53P]://
                    ||  d_vp1[x_1] !=( DUH+DUH-u_1 )//::[53P]://
                    ||  d_vp1[y_1] !=( DUH+DUH-u_1 )//::[53P]://
                    ){                              //::[53P]://
                        f_c.r +=(0.50);             //::[53P]://
                    };;                             //::[53P]://
                    if( mv0.x <=(1.00)              //::[53P]://
                    ||  mv0.y <=(1.00)              //::[53P]://
                    ){                              //::[53P]://
                        f_c.b +=(0.5);//: $_BLUEBUG_$   [53P]://
                    };;                             //::[53P]://
                                                    //::[---]://
                };;                                 //::[52P]://
                //:----------------:#_LINE_DEBUG_HACK_#:[52P]://
                                                    //::[---]://
            }//:::::::::::::::::::::::[_f1main_]:// //::[09P]://
        `);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; //::[09P]://
        //:--------------------:#__MAP_RENDERER_FRAG__#:[45P]://
                                                    //::[---]://
        //:#__NPC_RENDERER_VERT__#:[28P]:--------------------://
                                                    //::[---]://
        d_sv2 =(d_hed)+(`                           //::[12P][10P]://
                                                    //::[---]://
            #define T_F texelFetch                  //::[32P]://
            #define SBX (  int( ${ c_sbx } ) )      //::[32P]://
            #define SBY (  int( ${ c_sby } ) )      //::[32P]://
            #define DUC ( uint( ${ c_duc } ) )      //::[44P]://
            #define DUT ( uint( ${ c_dut } ) )      //::[68P]://
            #define IV2 ivec2                       //::[25P]://
            #define UV4 uvec4                       //::[25P]://
            #define F_7FFF  ( float(0x7FFF     ) )  //::[25P]://
            #define HALFMAX ( float(0x7FFFFFFF ) )  //::[28P]://
            #define I32  int                        //::[69P]://
            #define U32 uint                        //::[19P]://
            #define U_7F   U32(0x7F  )              //::[19P]://  
            #define F32 float                       //::[18P]://
            #define SID ( gl_VertexID )             //::[18P]://
            #define UNI uniform                     //::[41P]://
            #define UV2 uvec2                       //::[43P]://
            #define FV2  vec2                       //::[69P]://
            #define x_0 ( uint( ${ x_0 } ) )        //::[43P]://
            #define x_1 ( uint( ${ x_1 } ) )        //::[43P]://
            #define y_0 ( uint( ${ y_0 } ) )        //::[43P]://
            #define y_1 ( uint( ${ y_1 } ) )        //::[43P]://
            #define u_1 ( uint(    0x1   ) )        //::[43P]://
                                                    //::[---]://
            precision highp usampler2D ;            //::[18P]://
            uniform   usampler2D d_p2k ;            //::[18P]://
            uniform U32 d_tik          ;            //::[19P]://
            uniform U32 d_sss          ;            //::[36P]://
            UNI UV4 d_poi_vpc ; //: ViewPort_C ::// //::[41P]://
            UNI UV4 d_poi_vp0 ; //: ViewPort_0 ::// //::[41P]://
            UNI UV4 d_poi_vp1 ; //: ViewPort_1 ::// //::[41P]://
                                                    //::[---]://
            void main( ){   //::::::::[_v2main_]:// //::[12P]://
                                                    //::[---]://
                //:#_GL_VIEWHACK_#:[41P]:--------------------://
                    U32 viewhak =(  d_poi_vpc[0]    //::[41P]://
                                  + d_poi_vp0[0]    //::[41P]://
                                  + d_poi_vp1[0] ); //::[41P]://
                    if( viewhak > U32(0) ){      }; //::[41P]://
                //:--------------------:#_GL_VIEWHACK_#:[41P]://
                                                    //::[---]://
                IV2 ixy ; //: @ixy@ : Signed_INT.XY     [25P]://        
                UV4 tex ; //: @tex@ : U32 RGBA Texel    [25P]://
                                                    //::[---]://
                U32 gtx ; //: @gtx@ : Global_Tile_____X [69P]   [---]://
                U32 gty ; //: @gty@ : Global_Tile_____Y [69P]   [---]://
                U32 dix ; //: @dix@ : Disc_Internal___X [69P]   [---]://
                U32 diy ; //: @diy@ : Disc_Internal___Y [69P]   [---]://
                U32 u_x ; //: @u_x@ : Uint32_Position.X [69P]   [25P]://
                U32 u_y ; //: @u_y@ : Uint32_Position.Y [69P]   [34P]://
                                                    //::[---]://
                F32 snx ; //: @snx@ : $_Sprite_NDC_X_$  [18P]://
                F32 sny ; //: @sny@ : $_Sprite_NDC_Y_$  [18P]://
                                                    //::[---]://
                UV2 mv0 ; //: Magnitude_of[__vp0__]     [43P]://
                UV2 mv1 ; //: Magnitude_of[__vp1__]     [43P]://
                UV2 duf ; //: Discrete_Units_Per_Frag   [43P]://
                                                    //::[---]://
                UV2 vss ; //: @vss@ : Vector_SpriteSize [44P]://
                U32 uss ; //: @uss@ : Uint32_SpriteSize [44P]://
                F32 fss =( F32(d_sss) );//:$_F32_SSS_$  [36P]://
                                                    //::[---]://
                //:#__CALC_SPRITE_SCREEN_SIZE_#:[43P]:-------://
                //:#__CALC_SSS__#:[43P]:---------------------://
                #define _0_ d_poi_vp0  //: DESTIN_AKA_SCREEN ://
                #define _1_ d_poi_vp1  //: SOURCE_TILE_DATA  ://
                                                     //:[43P]://
                    mv0 =UV2(_0_[x_1]-_0_[x_0]+u_1   //:[43P]://
                        ,    _0_[y_1]-_0_[y_0]+u_1 );//:[43P]://
                    mv1 =UV2(_1_[x_1]-_1_[x_0]+u_1   //:[43P]://
                        ,    _1_[y_1]-_1_[y_0]+u_1 );//:[43P]://
                                                     //:[43P]://
                //: duf =($_DUN_SEL_$)/($_MON_PIX_$);   [43P]://
                    duf =(    mv1    )/(    mv0    );//:[43P]://
                                                     //:[43P]://
                    //:#__VUF_SPRITE_SIZES__#:[44P]:---------://
                                                    //::[44P]://
                    vss =UV2( DUC    /    duf   );; //::[44P]://
                    uss =max( vss.x  ,    vss.y );; //::[44P]://
                    fss =F32( u_1 + uss + u_1   );; //::[44P]://
                                                    //::[44P]://
                    //:---------:#__VUF_SPRITE_SIZES__#:[44P]://
                                                    //::[---]://
                #undef _0_                          //::[43P]://
                #undef _1_                          //::[43P]://
                //:---------------------:#__CALC_SSS__#:[43P]://
                //:-------:#__CALC_SPRITE_SCREEN_SIZE_#:[43P]://
                                                    //::[---]://
                ixy.x =( SBX + SID );//:$_COL_SPRITE_$  [32P]   [25P]://
                ixy.y =( SBY + (0) );//:$_ROW_ATTRIB_$  [32P]   [25P]://
                                                    //::[---]://
                //:#_CALC_DUG_XY_#:[69P]:--------------------://
                                                    //::[---]://
                    ixy.y =( I32(${ c_sai_gtx }));  //::[69P]   [32P]://
                    tex   =( T_F(d_p2k,ixy,0) );    //::[32P]   [25P]://
                    gtx   =(   tex.r << 24          //::[25P]://
                             | tex.g << 16          //::[25P]://
                             | tex.b <<  8          //::[25P]://
                             | tex.a <<  0          //::[25P]://
                           );                       //::[25P]://
                                                    //::[---]://
                    ixy.y =( I32(${ c_sai_gty }));  //::[69P]   [34P]://
                    tex   =( T_F(d_p2k,ixy,0) );    //::[34P]://
                    gty   =(   tex.r << 24          //::[34P]://
                             | tex.g << 16          //::[34P]://
                             | tex.b <<  8          //::[34P]://
                             | tex.a <<  0          //::[34P]://
                           );                       //::[34P]://
                                                    //::[---]://
                    ixy.y =( I32(${ c_sai_dix }));  //::[69P]://
                    tex   =( T_F(d_p2k,ixy,0) );    //::[69P]://
                    dix   =(   tex.r << 24          //::[69P]://
                             | tex.g << 16          //::[69P]://
                             | tex.b <<  8          //::[69P]://
                             | tex.a <<  0          //::[69P]://
                           );                       //::[69P]://
                                                    //::[69P]://
                    ixy.y =( I32(${ c_sai_diy }));  //::[69P]://
                    tex   =( T_F(d_p2k,ixy,0) );    //::[69P]://
                    diy   =(   tex.r << 24          //::[69P]://
                             | tex.g << 16          //::[69P]://
                             | tex.b <<  8          //::[69P]://
                             | tex.a <<  0          //::[69P]://
                           );                       //::[69P]://
                                                    //::[69P]://
                    u_x=( gtx*DUT )+(dix);          //::[69P]://
                    u_y=( gty*DUT )+(diy);          //::[69P]://
                                                    //::[---]://
                //:--------------------:#_CALC_DUG_XY_#:[69P]://
                                                    //::[---]://
                //:#_PER_ON_VP1_#:[68P]:---------------------://
                                                    //::        [---]://
                    UV2 dug=UV2( u_x , u_y );       //::[69P]   [68P]://
                                                    //::        [---]://
                    FV2 pop_vp1 =FV2(               //::[68P]://
                            dug.x - d_poi_vp1[x_0]  //::[68P]://
                        ,   dug.y - d_poi_vp1[y_0]  //::[68P]://
                    );;                             //::[68P]://
                    FV2 rng_vp1 =FV2( mv1 - u_1 );  //::[68P]://
                                                    //::[68P]://
                    FV2 per_vp1 =FV2( pop_vp1       //::[68P]://
                                  /   rng_vp1   );  //::[68P]://
                                                    //::[68P]://
                //:---------------------:#_PER_ON_VP1_#:[68P]://
                //:#_CONVERT_TO_NDC_#:[68P]:-----------------://
                #define P_X (per_vp1.x ) //:PERCENT_X   [68P]://
                #define P_Y (per_vp1.y ) //:PERCENT_Y   [68P]://
                                                    //::[68P]://
                    snx =(((       P_X )*2.0)-1.0);;//::[68P]://
                    sny =((( 1.0 - P_Y )*2.0)-1.0);;//::[68P]://
                                                    //::[68P]://
                #undef  P_X                         //::[68P]://
                #undef  P_Y                         //::[68P]://
                //:-----------------:#_CONVERT_TO_NDC_#:[68P]://
                                                    //::[18P]://
                gl_PointSize=( fss );               //::[36P]   [18P]://
                gl_Position = vec4(                 //::[18P]://
                                                    //::[18P]://
                    snx                             //::[18P]://
                ,   sny                             //::[18P]://
                ,   0.0                             //::[18P]://
                ,   1.0                             //::[18P]://
                );                                  //::[18P]://
                                                    //::[---]://
            }//:::::::::::::::::::::::[_v2main_]:// //::[12P]://
        `);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; //::[10P]://
                                                    //::[---]://
        //:--------------------:#__NPC_RENDERER_VERT__#:[28P]://
        //:#__NPC_RENDERER_FRAG__#:[28P]:--------------------://
                                                    //::[---]://
        d_sf2 =(d_hed)+(`                           //::[12P][10P]://
                                                    //::[---]://
            out vec4 sfc ;  //:$_SPRITE_FC_$://     //::[17P]://
                                                    //::[---]://
            void main( ){   //::::::::[_f2main_]:// //::[12P]://
                                                    //::[---]://
                sfc =vec4(0,1,0,1);//:GREEN://      //::[17P]://
                                                    //::[---]://
            }//:::::::::::::::::::::::[_f2main_]:// //::[12P]://
        `);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; //::[10P]://
                                                    //::[---]://
        //:--------------------:#__NPC_RENDERER_FRAG__#:[28P]://
                                                    //::[---]://
        //:#__VER_THEN_FRA__#:[09P]:----------://   //::[10P]://
                                                    //::[10P]://
            d_ver =( d_wgl.VERTEX_SHADER   );;;;;   //::[10P]://
            d_fra =( d_wgl.FRAGMENT_SHADER );;;;;   //::[10P]://
                                                    //::[10P]://
            d_ov1 = d_wgl.createShader(  d_ver );   //::[14P][10P]://
            d_ov2 = d_wgl.createShader(  d_ver );   //::[10P]://
            d_of1 = d_wgl.createShader(  d_fra );   //::[10P]://
            d_of2 = d_wgl.createShader(  d_fra );   //::[10P]://
                                                    //::[10P]://
            d_wgl.shaderSource(  d_ov1 , d_sv1 );   //::[14P][10P]://
            d_wgl.shaderSource(  d_ov2 , d_sv2 );   //::[10P]://
            d_wgl.shaderSource(  d_of1 , d_sf1 );   //::[10P]://
            d_wgl.shaderSource(  d_of2 , d_sf2 );   //::[10P]://
                                                    //::[---]://
            F_COMPILE_SHADER( d_ov1            );   //::[14P][11P][10P]://
            F_COMPILE_SHADER( d_ov2            );   //::[11P][10P]://
            F_COMPILE_SHADER( d_of1            );   //::[11P][10P]://
            F_COMPILE_SHADER( d_of2            );   //::[11P][10P]://
                                                    //::[---]://
        //:----------:#__VER_THEN_FRA__#:[09P]://   //::[10P]://
                                                    //::[---]://
        //:#__ALLOC_PID_ARR__#:[13P]:---------://   //::[13P]://
                                                    //::[13P]://
            d_arr_pid =( new Array( 2 ) );          //::[13P]://
                                                    //::[13P]://
        //:---------:#__ALLOC_PID_ARR__#:[13P]://   //::[13P]://
        //:#__PROGRAM_CREATION__#:[13P]:------://   //::[13P]://
                                                    //::[13P]://
            //:$_PROGRAM_ID_IS_OBJECT_IN_WGL_$://   //::[13P]://
                                                    //::[13P]://
            d_pid=d_wgl.createProgram();            //::[13P]://
            d_wgl.attachShader( d_pid , d_ov1 );    //::[14P][13P]://
            d_wgl.attachShader( d_pid , d_of1 );    //::[13P]://
            d_wgl.linkProgram(  d_pid );;;;;;;;;    //::[15P]://
                                                    //::[13P]://
            d_arr_pid[ 0 ]=(  d_pid );              //::[13P]://
                                                    //::[---]://
            d_pid=d_wgl.createProgram();            //::[17P]://
            d_wgl.attachShader( d_pid , d_ov2 );    //::[17P]://
            d_wgl.attachShader( d_pid , d_of2 );    //::[17P]://
            d_wgl.linkProgram(  d_pid );;;;;;;;;    //::[17P]://
                                                    //::[17P]://
            d_arr_pid[ 1 ]=( d_pid );               //::[17P]://
                                                    //::[---]://
        //:------:#__PROGRAM_CREATION__#:[13P]://   //::[13P]://
        //:#__PROGRAM_SELECT__#:[13P]:--------://   //::[13P]://
                                                    //::[13P]://
        //- d_wgl.useProgram(d_arr_pid[ 0 ]); -//   //::[17P][13P]://
                                                    //::[13P]://
        //:--------:#__PROGRAM_SELECT__#:[13P]://   //::[13P]://
        //:#__UNIFORM_INIT__#:[19P]:------------:// //::[19P]://
                                                    //::[19P]://
            d_tik =( 0-1 );//: Game Ticker Time :// //::[19P]://
                                                    //::[19P]://
        //:------------:#__UNIFORM_INIT__#:[19P]:// //::[19P]://
        //:#__UNIFORM_ADDRESSES__#:[19P]:-------:// //::[19P]://
                                                    //::[19P]://
            let GUL =( d_wgl                        //::[19P]://
                        .getUniformLocation         //::[19P]://
                        .bind( d_wgl ) );;;;        //::[19P]://
                                                    //::[---]://
            d_pid =( d_arr_pid[ 0 ] );;;;;;;;;;;;   //::[37P]://
            d_wgl.useProgram(d_pid  );;;;;;;;;;;;   //::[37P]://
            d_vpc_loc=( GUL( d_pid , "d_vpc" ));;   //::[37P]:// NOTICE_ME_SENPAI: REFACTOR[ d_vpc ===> d_til_vpc ]
            d_vp0_loc=( GUL( d_pid , "d_vp0" ));;   //::[37P]:// NOTICE_ME_SENPAI: REFACTOR[ d_vp0 ===> d_til_vp0 ]
            d_vp1_loc=( GUL( d_pid , "d_vp1" ));;   //::[37P]:// NOTICE_ME_SENPAI: REFACTOR[ d_vp1 ===> d_til_vp1 ]
                                                    //::[---]://
            d_pid =( d_arr_pid[ 1 ] );;;;;;;;;;;;   //::[19P]://
            d_wgl.useProgram(d_pid  );;;;;;;;;;;;   //::[19P]://
            d_poi_vpc=( GUL( d_pid , "d_poi_vpc" ));//::[41P]://
            d_poi_vp0=( GUL( d_pid , "d_poi_vp0" ));//::[41P]://
            d_poi_vp1=( GUL( d_pid , "d_poi_vp1" ));//::[41P]://
            d_tik_loc=( GUL( d_pid , "d_tik" ));;   //::[19P]://
            d_p2k_loc=( GUL( d_pid , "d_p2k" ));;   //::[24P]://
            d_sss_loc=( GUL( d_pid , "d_sss" ));;   //::[36P]://
                                                    //::[19P]://
        //:-------:#__UNIFORM_ADDRESSES__#:[19P]:// //::[19P]://
        //:#__UNIFORM_ADDR_CHK__#:[27P]:--------:// //::[27P]://
        {                                           //::[27P]://
            let E =( F_ERROR     );                 //::[27P]://
            let L =( console.log );                 //::[34P]://
                                                    //::[27P]://
            if(null == d_tik_loc){ L("[_TIK_]"); }; //::[34P][27P]://
            if(null == d_p2k_loc){ E("[_P2K_]"); }; //::[27P]://
                                                    //::[27P]://
            if(null != d_p2k_loc){                  //::[27P]://
                                                    //::[27P]://
                console.log( "[P2K]:",d_p2k_loc);   //::[27P]://
            };;                                     //::[27P]://
        }                                           //::[27P]://
        //:--------:#__UNIFORM_ADDR_CHK__#:[27P]:// //::[27P]://
        //:#__WIREUP_KEYBOARD__#:[20P]:---------:// //::[20P]://
                                                    //::[20P]://
            d_doc.addEventListener(                 //::        [20P]://
                "keydown"        //: Event Type :// //::        [20P]://
            ,   F_KEYBOARD_CONTROL //: Callback :// //::[39P]   [20P]://
            );;                                     //::        [20P]://
                                                    //::[20P]://
        //:---------:#__WIREUP_KEYBOARD__#:[20P]:// //::[20P]://
        //:#__INIT_CPU_TEXTURE__#:[21P]:--------:// //::[21P]://
        {                                           //::[21P]://
            d_pix2048 =(new Uint8Array(d_bytelen)); //::[21P]://
                                                    //::[21P]://
        let dpx ; //: @dpx@ : Data_Pixel_X ::::::// //::[21P]://
        let dpy ; //: @dpy@ : Data_Pixel_Y ::::::// //::[21P]://
        let dpi ; //: @dpi@ : Data_Pixel_INDEX ::// //::[21P]://
        let dpc ; //: @dpc@ : Data_Pixel_COMPO ::// //::[21P]://
        for(dpy = 0 ; dpy <=( 2048-1 ) ; dpy++ ){   //::[21P]://
        for(dpx = 0 ; dpx <=( 2048-1 ) ; dpx++ ){   //::[21P]://
                                                    //::[21P]://
            dpi =( dpx + ( dpy * 2048 ) );          //::[21P]://
            dpc =( dpi * 4 );;;;;;;;;;;;;;          //::[21P]://
                                                    //::[21P]://
            d_pix2048[ dpc + 0 ]=( dpx % 255 );     //::[21P]://
            d_pix2048[ dpc + 1 ]=( dpy % 255 );     //::[21P]://
            d_pix2048[ dpc + 2 ]=( dpi % 255 );     //::[21P]://
            d_pix2048[ dpc + 3 ]=(      0xFF );     //::[21P]://
                                                    //::[21P]://
        };;};;                                      //::[21P]://
        }                                           //::[21P]://
        //:--------:#__INIT_CPU_TEXTURE__#:[21P]:// //::[21P]://
        //:#__HACK_CPU_TEXTURE__#:[26P]:--------:// //::[26P]://
        if( c_hack_cpu_texture >= 1 ){              //::[26P]://
                                                    //::[26P]://
            let dex ; //: @dex@ : Index of ____ :// //::[26P]://
            let m_i =( d_bytelen - 1 );             //::[26P]://
            if( m_i !=( (2048*2048*4)-1) ){         //::[26P]://
                                                    //::[26P]://
                F_ERROR( "[_$_BAD_MAX_DEX_$_]" );   //::[26P]://
            };;                                     //::[26P]://
            for(dex = 0 ; dex <=( m_i ) ; dex++){   //::[26P]://
                                                    //::[26P]://
                d_pix2048[ dex ]=( 0xFF );          //::[26P]://
            };;                                     //::[26P]://
        };;                                         //::[26P]://
        //:--------:#__HACK_CPU_TEXTURE__#:[26P]:// //::[26P]://
        //:#__ALLOC_GPU_TEXTURE__#:[22P]:-------:// //::[22P]://
                                                    //::[22P]://
            d_p2k_tex =( d_wgl.createTexture() );;  //::[22P]://
            //:        OPENGL[ glGenTextures() ]:// //::[22P]://
                                                    //::[---]://
            //:#_ACTIVATE_B4_BIND_#:[24P]:------:// //::[24P]://
                                                    //::[24P]://
                d_wgl.activeTexture(                //::[24P]://
                    d_wgl.TEXTURE0                  //::[24P]://
                +   c_tui_p2k                       //::[24P]://
                );;                                 //::[24P]://
            //:------:#_ACTIVATE_B4_BIND_#:[24P]:// //::[24P]://
                                                    //::[---]://
            d_wgl.bindTexture(                      //::[22P]://
                                                    //::[22P]://
                d_wgl.TEXTURE_2D  //: $_T_O_T_$ :// //::[22P]://
            ,   d_p2k_tex         //: $_T_HAN_$ :// //::[22P]://
            );;                                     //::[22P]://
            //:---------------------------------:// //::[22P]://
            //:                                 :// //::[22P]://
            //:  WARNING : " texStorage2D "     :// //::[22P]://
            //:  NOT_FOR : " WebGL2 " Context !!:// //::[22P]://
            //:                                 :// //::[22P]://
            //:---------------------------------:// //::[22P]://
                                                    //::[---]://
            //:#__PARAM_AND_STORE__#:[27P]:------------------://
                                                    //::[27P]://
            let __must_do_before_tex_image_2d__=0   //::[27P]://
            ,   t2d = d_wgl.TEXTURE_2D              //::[27P]://
            ,   _n_ = d_wgl.NEAREST                 //::[27P]://
            ,   _e_ = d_wgl.CLAMP_TO_EDGE           //::[27P]://
            ,   min = d_wgl.TEXTURE_MIN_FILTER      //::[27P]://
            ,   mag = d_wgl.TEXTURE_MAG_FILTER      //::[27P]://
            ,   _s_ = d_wgl.TEXTURE_WRAP_S          //::[27P]://
            ,   _t_ = d_wgl.TEXTURE_WRAP_T          //::[27P]://
            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; //::[27P]://
            d_wgl.texParameteri( t2d, min , _n_ );; //::[27P]://
            d_wgl.texParameteri( t2d, mag , _n_ );; //::[27P]://
            d_wgl.texParameteri( t2d, _s_ , _e_ );; //::[27P]://
            d_wgl.texParameteri( t2d, _t_ , _e_ );; //::[27P]://
                                                    //::[27P]://
            d_wgl.pixelStorei(                      //::[27P]://
                                                    //::[27P]://
                d_wgl.UNPACK_ALIGNMENT              //::[27P]://
            ,   (4)                                 //::[27P]://
            );;                                     //::[27P]://
            //:------------------:#__PARAM_AND_STORE__#:[27P]://
                                                    //::[---]://
            d_wgl.texImage2D(  //:--:[ T_I_2_D ]:// //::[22P]://
                d_wgl.TEXTURE_2D    //:$_T_O_T_$:// //::[22P]://
            ,   0                   //:$_L_O_D_$:// //::[22P]://
            ,   d_wgl.RGBA8UI       //:$_C_FMT_$:// //::[22P]://
                //:-----------------------------:// //::[22P]://
            ,   2048     //: WIDTH  / PIX_WID   :// //::[22P]://
            ,   2048     //: HEIGHT / PIX_HIG   :// //::[22P]://
            ,   0        //: BORDER             :// //::[22P]://
                //:-----------------------------:// //::[22P]://
            ,   d_wgl.RGBA_INTEGER  //:$_G_FMT_$:// //::[22P]://
            ,   d_wgl.UNSIGNED_BYTE //:$_G_FMT_$:// //::[22P]://
            ,   d_pix2048 //: ARRAY_BUFFER_VIEW :// //::[22P]://
            );; //:-----------------:[ T_I_2_D ]:// //::[22P]://
                                                    //::[22P]://
        //:-------:#__ALLOC_GPU_TEXTURE__#:[22P]:// //::[22P]://
        //:#__WIRE_UP_SAMPLER__#:[24P]:---------:// //::[24P]://
        {                                           //::[24P]://
            let zero_offset=( 0 );                  //::[24P]://
                                                    //::[24P]://
            d_wgl.uniform1i(     d_p2k_loc          //::[24P]://
            ,  zero_offset + c_tui_p2k     );;      //::[24P]://
                                                    //::[24P]://
        };;                                         //::[24P]://
        //:---------:#__WIRE_UP_SAMPLER__#:[24P]:// //::[24P]://
        //:#__HAS_BEEN_SETUP__#:[40P]:----------:// //::[40P]://
                                                    //::[40P]://
            d_ini =( 1 ); /** Setup/Initialized **/ //::[40P]://
                                                    //::[40P]://
        //:----------:#__HAS_BEEN_SETUP__#:[40P]:// //::[40P]://
                                                    //::[---]://
    };;                                             //::[05P]://
    //:====================================:#__SETUP__#:[05P]://
    ////////////////////////////////////////////////////////////
    //:#__HIGH_LEVEL_FOLLOW_CAMERA_UPDATE__#:[57P]:----------://
    let F_HIGH_LEVEL_FOLLOW_CAMERA_UPDATE =( )=>{   //::[57P]://
                                                    //::[---]://
        const GET =( F_GET_SPRITE_PROPERTY_VALUE ); //::[58P]://
                                                    //::[---]://
        const ami =( d_marione );//:$_AMI_WHAT_$:// //::[61P]://
                                                    //::[61P]://
        let gtx =( GET(ami,c_sai_gtx) );            //::[61P]://
        let gty =( GET(ami,c_sai_gty) );            //::[61P]://
        let dix =( GET(ami,c_sai_dix) );            //::[61P]://
        let diy =( GET(ami,c_sai_diy) );            //::[61P]://
                                                    //::[61P]://
        let dux =( (c_dut*gtx)  +dix  );            //::[61P]://
        let duy =( (c_dut*gty)  +diy  );            //::[61P]://
                                                    //::[61P]://
          d_cdx =( dux );                           //::[61P]://
          d_cdy =( duy );                           //::[61P]://
          d_czp =( 0.0 );                           //::[61P]://
                                                    //::[---]://
    };;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//::[57P]://
    //:----------:#__HIGH_LEVEL_FOLLOW_CAMERA_UPDATE__#:[57P]://
    //:#__SNAP_LOW_LEV_CAM_TO_HIGH_LEV_CAM__#:[57P]:---------://
    let F_SNAP_LOW_LEV_CAM_TO_HIGH_LEV_CAM =( )=>{  //::[57P]://
                                                    //::[---]://
        let v_w ; //: @v_w@ : vp1's plank_width  :::::::[62P]://
        let v_h ; //: @v_h@ : vp1's plank_height :::::::[62P]://
        let cmt ; //: @cmt@ : camera_magnitude_target ::[62P]://
        let per ; //: @per@ : Percent( towards:c_cm0 ) :[62P]://
                                                    //::[---]://
        let mv1_x;//: @mv1_x@ : Magnitude_of_VP1.X  //::[65P]://
        let mv1_y;//: @mv1_y@ : Magnitude_of_VP1.Y  //::[65P]://
                                                    //::[65P]://
        let cm0_x;//: @cm0_x@ : Proportional_To[ vp0 ]  [65P]://
        let cm0_y;//: @cm0_y@ : Proportional_To[ vp0 ]  [65P]://
                                                    //::[---]://
        let cmt_x;//: @cmt_x@ : Proportional_To[ vp0 ]  [63P]://
        let cmt_y;//: @cmt_y@ : Proportional_To[ vp0 ]  [63P]://
                                                    //::[---]://
        //:#_TARGET_AND_PERCENT_#:[62P]:---------------------://
            if( 0.0 === d_czp ){                    //::[62P]://
                                                    //::[62P]://
                cmt=(   c_cm0 );                    //::[62P]://
                per=( 0*0.000 );                    //::[62P]://
            }else                                   //::[62P]://
            if( d_czp > 0.0 && d_czp <=(0+1.0) ){   //::[62P]://
                                                    //::[62P]://
                cmt=(   c_cmj );                    //::[62P]://
                per=( 0+d_czp );                    //::[62P]://
            }else                                   //::[62P]://
            if( d_czp < 0.0 && d_czp >=(0-1.0) ){   //::[62P]://
                                                    //::[62P]://
                cmt=(   c_cmz );                    //::[62P]://
                per=( 0-d_czp );                    //::[62P]://
            }else{                                  //::[62P]://
                ERR( "[_OOB_CZP_]" );               //::[62P]://
            };;                                     //::[62P]://
        //:---------------------:#_TARGET_AND_PERCENT_#:[62P]://
        ////////////////////////////////////////////////////////
        //:#_CAMERA_RATIO_#:[63P]:---------------------------://
        {                                           //::[63P]://
            let mv0_x ; //: Magnitude[ vp0 ].X :::////::[63P]://
            let mv0_y ; //: Magnitude[ vp0 ].Y :::////::[63P]://
                                                    //::[63P]://
            let fac_x ; //: scale_FAC_tor.X ::::::////::[63P]://
            let fac_y ; //: scale_FAC_tor.Y ::::::////::[63P]://
                                                    //::[63P]://
            mv0_x =( d_vp0[ x_1 ]-d_vp0[ x_0 ]+1 ); //::[63P]://
            mv0_y =( d_vp0[ y_1 ]-d_vp0[ y_0 ]+1 ); //::[63P]://
                                                    //::[63P]://
            const c_csm_crushit =( 1 );;;;;;;;;;;;; //::[63P]://
            const c_csm_elongit =( 2 );;;;;;;;;;;;; //::[63P]://
            let   d_csm         =( c_csm_crushit ); //::[63P]://
                                                    //::[63P]://
            if( 0+d_csm+0 === c_csm_elongit ){      //::[63P]://
                                                    //::[63P]://
                fac_x =(F_MAX(mv0_x,mv0_y)/mv0_x);  //::[63P]://
                fac_y =(F_MAX(mv0_y,mv0_x)/mv0_y);  //::[63P]://
            }else                                   //::[63P]://
            if( 0+d_csm+0 === c_csm_crushit ){      //::[63P]://
                                                    //::[63P]://
                fac_x =(mv0_x/F_MAX(mv0_y,mv0_x));  //::[63P]://
                fac_y =(mv0_y/F_MAX(mv0_x,mv0_y));  //::[63P]://
            };;                                     //::[63P]://
                                                    //::[63P]://
            cm0_x =( c_cm0 * fac_x );//: $_0_PER_MAG_$  [65P]://
            cm0_y =( c_cm0 * fac_y );//: $_0_PER_MAG_$  [65P]://
                                                    //::[---]://
            cmt_x =(   cmt * fac_x );//: $_1_PER_MAG_$  [65P]   [63P]://
            cmt_y =(   cmt * fac_y );//: $_1_PER_MAG_$  [65P]   [63P]://
        }                                           //::[63P]://
        //:---------------------------:#_CAMERA_RATIO_#:[63P]://
        //:#_SCALE_TO_TARGET_#:------------------------:[65P]://
        {                                           //::[65P]://
            let p_0 =( 1.0-per );; //: $_BEG_PERCENT_$  [65P]://
            let p_1 =(     per );; //: $_END_PERCENT_$  [65P]://
                                                    //::[65P]://
            mv1_x =( ( cm0_x * p_0 )                //::[65P]://
                  +  ( cmt_x * p_1 ) );;            //::[65P]://
            mv1_y =( ( cm0_y * p_0 )                //::[65P]://
                  +  ( cmt_y * p_1 ) );;            //::[65P]://
        }                                           //::[65P]://
        //:------------------------:#_SCALE_TO_TARGET_#:[65P]://
        //:#_MOVE_TO_TARGET_#:[66P]:-------------------------:// // [66P]
                                                    //::[66P]:// // [66P]
            //:- - - - - - - - - - - -- - - - - - - - - - - -:// // [66P]
            //: [ ][ ][ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ][ ]     :// // [66P]
            //: [ ]<-----[7]----->[ ] [ ]<--[ 06 ]-->[ ]     :// // [66P]
            //: [3][2][1][0][1][2][3] [2][1][0][1][2][3]     :// // [66P]
            //:                                              :// // [66P]
            //: (7/2)==(3)            (6/2)==(3)             :// // [66P]
            //: ODD: (MAG/2)+0)       EVE.LEF : (MAG/2)-1    :// // [66P]
            //:                       EVE.RIG : (MAG/2)+0    :// // [66P]
            //:                                              :// // [66P]
            //: @hv1_x@ : Half(magnitude)Viewport_1.X        :// // [66P]
            //: @hv1_y@ : Half(magnitude)Viewport_1.Y        :// // [66P]
            //:                                              :// // [66P]
            //:- - - - - - - - - - - -- - - - - - - - - - - -:// // [66P]
                                                    //::[66P]:// // [66P]
            let hv1_x =( Math.floor( mv1_x / 2 ) ); //::[66P]:// // [66P]
            let hv1_y =( Math.floor( mv1_y / 2 ) ); //::[66P]:// // [66P]
                                                    //::[66P]:// // [66P]
            d_vp1[ x_0 ]=( d_cdx - hv1_x );//: WIDE.LEF [66P]:// // [66P]
            d_vp1[ x_1 ]=( d_cdx + hv1_x );//: WIDE.RIG [66P]:// // [66P]
            d_vp1[ y_0 ]=( d_cdy - hv1_y );//: WIDE.TOP [66P]:// // [66P]
            d_vp1[ y_1 ]=( d_cdy + hv1_y );//: WIDE.BOT [66P]:// // [66P]
                                                    //::[66P]:// // [66P]
            //:#_POST_ADJUSTMENTS_#:[66P]:-------------------:// // [66P]
                                   //:TAG[ POST_ADJUSTMENTS ]:// // [66P]
                                                    //::[66P]:// // [66P]
                if(0==mv1_x & 0x1){ d_vp1[x_0]+=1 ;};//:[66P]:// // [66P]
                if(0==mv1_y & 0x1){ d_vp1[y_0]+=1 ;};//:[66P]:// // [66P]
                                                    //::[66P]:// // [66P]
            //:-------------------:#_POST_ADJUSTMENTS_#:[66P]:// // [66P]
                                                                 // [66P]
        //:-------------------------:#_MOVE_TO_TARGET_#:[66P]:// // [66P]
       
    };;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;//::[57P]://
    //:---------:#__SNAP_LOW_LEV_CAM_TO_HIGH_LEV_CAM__#:[57P]://
    ////////////////////////////////////////////////////////////
    //:#__LOOP_FOREVER__#:[06P]:=============================://
    let F_LOOP_FOREVER =( )=>{                      //::[06P]://
                                                    //::[06P]://
        console.log( "[ K_A_N_J_I ][ C_O_D_E_R ]" );//::[06P]://
                                                    //::[---]://
        //:#__CAM_UPDATE__#:[57P]:---------------------------://
                                                    //::[57P]://
            F_HIGH_LEVEL_FOLLOW_CAMERA_UPDATE( );   //::[57P]://
            F_SNAP_LOW_LEV_CAM_TO_HIGH_LEV_CAM( );  //::[57P]://
                                                    //::[57P]://
        //:---------------------------:#__CAM_UPDATE__#:[57P]://
        //:#__GAME_STATE_UPDATE__:[19P]:---------------------://
                                                    //::[---]://
            d_wgl.useProgram( d_arr_pid[ 0 ]    );  //::[37P]://
            d_wgl.uniform4uiv(d_vpc_loc , d_vpc );  //::[37P]://
            d_wgl.uniform4uiv(d_vp0_loc , d_vp0 );  //::[37P]://
            d_wgl.uniform4uiv(d_vp1_loc , d_vp1 );  //::[37P]://
                                                    //::[---]://
            d_wgl.useProgram( d_arr_pid[ 1 ]    );  //::[19P]://
            d_wgl.uniform4uiv(d_poi_vpc , d_vpc );  //::[41P]://
            d_wgl.uniform4uiv(d_poi_vp0 , d_vp0 );  //::[41P]://
            d_wgl.uniform4uiv(d_poi_vp1 , d_vp1 );  //::[41P]://
                                                    //::[---]://
                                          d_tik++;  //::[19P]://
            d_wgl.uniform1ui( d_tik_loc , d_tik );  //::[19P]://
                                                    //::[---]://
            d_sss =( d_tik % (64+1) );;;;;;;;;;;;;  //::[36P]://
            d_wgl.uniform1ui( d_sss_loc , d_sss );  //::[36P]://
                                                    //::[---]://
        //:---------------------:#__GAME_STATE_UPDATE__:[19P]://
        //:#__VIEWPORT_SETUP__:[14P]:------------------------://
                                                    //::[14P]://
            //:#__ALIGN_CONTEXT_TO_CANVAS__#:[14P]:----------://
                                                    //::[14P]://
                d_wgl.viewport( 0                   //::[14P]://
                            ,   0                   //::[14P]://
                            ,   d_can.width         //::[14P]://
                            ,   d_can.height        //::[14P]://
                );;                                 //::[14P]://
            //:----------:#__ALIGN_CONTEXT_TO_CANVAS__#:[14P]://
                                                    //::[14P]://
        //:------------------------:#__VIEWPORT_SETUP__:[14P]://
        //:#__CLEAR_SCREEN_AND_RENDER__#:[13P]:--------------://
                                                    //::[13P]://
            d_wgl.clear( d_wgl.COLOR_BUFFER_BIT );  //::[13P]://
            d_wgl.useProgram(d_arr_pid[ 0 ]);       //::[17P]://
            d_wgl.drawArrays(                       //::[13P]://
                d_wgl.TRIANGLE_STRIP                //::[14P][13P]://
            ,   0         //:$_1ST_VERT_DEX_$://    //::[14P][13P]://
            ,   4         //:$_NUM_VERT_IDS_$://    //::[14P][13P]://
            );;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    //::[13P]://
                                                    //::[13P]://
        //:--------------:#__CLEAR_SCREEN_AND_RENDER__#:[13P]://
        //:#__SPRITES_ON_TOP__#:[17P]:-----------------------://
                                                     //:[17P]://
            d_wgl.useProgram( d_arr_pid[ 1 ]     );; //:[17P]://
            d_wgl.drawArrays( d_wgl.POINTS , 0,3 );; //:[17P]://
                                                     //:[17P]://
        //:-----------------------:#__SPRITES_ON_TOP__#:[17P]://
                                                    //::[---]://
        d_win.requestAnimationFrame(F_LOOP_FOREVER);//::[06P]://
    };;                                             //::[06P]://
    //:=============================:#__LOOP_FOREVER__#:[06P]://
    //:#__C99_MAIN__#:[06P]:=================================://
    let F_C99_MAIN =( )=>{                          //::[06P]://
                                                    //::[06P]://
        F_SETUP( ); F_LOOP_FOREVER( );              //::[06P]://
    };;                                             //::[06P]://
    //:=================================:#__C99_MAIN__#:[06P]://
    //:#__CALL_MAIN__#:[06P]:================================://
                                                    //::[06P]://
        F_C99_MAIN( );                              //::[06P]://
                                                    //::[06P]://
    //:================================:#__CALL_MAIN__#:[06P]://
                                                    // [---=---]
/**#__DOC_SEC__#:[004_POI]:************************ ** [004_POI]
                                                       [004_POI]
    #__DOC_SEC__# :::::: DOCumentation_SECtion         [004_POI]
    #__GLOBALS__# :::::: All global (filescope) vars   [004_POI]
    #__ERROR__# :::::::: Error Function Section            [08P]
    #__SETUP__# :::::::: 1 Time Environment Setup Code     [05P]
                                                           [---]
    #__LOOP_FOREVER__# : Infinite [game/render] loop       [06P]
    #__C99_MAIN__#:::::: C99 Style Main Entry Point        [06P]
    #__CALL_MAIN__# :::: Simulate running executable       [06P]
                                                           [---]
    @F_@    : Prefix used for FUNCTIONS   , UPPERCASE      [05P]
    @d_@    : Prefix used for global DATA , lowercase      [05P]
    @d_win@ : global window   object  _______________      [05P]
    @d_doc@ : global document object  _______________      [07P]
    @d_bod@ : global body     object  _______________      [07P]
    @d_can@ : global canvas object                         [07P]
    @d_wgl@ : global WebGL  Context                        [07P]
    @W_V@ ::: Webgl_Version                                [07P]
    @d_wvc@ : W_V.Context ( WGL Context Version )          [07P]
    @d_wvs@ : W_V.Shader  ( WGL Shader  Version Directive )[07P]
                                                           [---]
    @d_pmf@ :::: global_data(d_) : Precious_Mediump_Float  [09P]
    @_v1main_@ : BOGUS : No vertex shader #1 code.         [09P]
    @_f1main_@ : Frag(shader) #1 - Main , scope marker.    [09P]
                                                           [09P]
    @SRC_VERT@ : source(SRC) code for VERTEX   shader.     [09P]
    @SRC_FRAG@ : source(SRC) code for FRAGMENT shader.     [09P]
                                                           [09P]
    $_SRC_VERT_1_TILES_$ :--------------------------------:[09P]
    $_SRC_FRAG_1_TILES_$ :--------------------------------:[09P]
                                                           [09P]
        The shader source code strings for rendering the   [09P]
        __TILE_MAP__ behind the point sprites. This shader [09P]
        will just be a "placeholder" shader that fills     [09P]
        the screen some simple easy pattern using the      [09P]
        frag coords.                                       [09P]
                                                           [09P]
        $_SV1_NOT_NEEDED_$ :--------------------------:    [09P]
                                                      |    [09P]
            d_sv1=( "$_SV1_NOT_NEEDED_$" );           |    [09P]
                                                      |    [09P]
            To explicitly state that we DONT_NEED     |    [09P]
            a vertex shader to create our simple      |    [09P]
            tile map renderer, as we can partition    |    [09P]
            the 2D screen space using nothing but     |    [09P]
            "gl_FragCoord".                           |    [09P]
                                                      |    [09P]
        :--------------------------: $_SV1_NOT_NEEDED_$    [09P]
                                                           [09P]
        @d_sv1@ : global_DATA(d_) - Shader(src)Vertex   #1 [09P]
        @d_sf1@ : global_DATA(d_) - Shader(src)Fragment #1 [09P]
                                                           [09P]
    :--------------------------------: $_SRC_FRAG_1_TILES_$[09P]
    :--------------------------------: $_SRC_VERT_1_TILES_$[09P]
    $_SRC_VERT_2_POINT_$ :--------------------------------:[09P]
    $_SRC_FRAG_2_POINT_$ :--------------------------------:[09P]
                                                           [09P]
        The shader source code strings for rendering the   [09P]
        __POINT_SPRITES__ in front of the tilemap fragments[09P]
        rendered by the __PREVIOUS_SHADER__ . This is the  [09P]
        shader we will be using for rendering NPC and      [09P]
        __PLAYER__ characters . What we learn from this    [09P]
        shader will be used to write the code for the      [09P]
        [ ARTEMIS ]sub-system within[ ATOMIC_IVY_MMO.JS ]. [09P]
                                                           [09P]
        Atomic Ivy MMO Source : github.com/KANJICODER/AIM  [09P]
        AIM == Atomic.Ivy.MMO.: FILE[ ATOMIC_IVY_MMO.JS ]  [09P]
                                                           [09P]
        @d_sv2@ : global_DATA(d_) - Shader(src)Vertex   #2 [09P]
        @d_sf2@ : global_DATA(d_) - Shader(src)Fragment #2 [09P]
                                                           [09P]
    :--------------------------------: $_SRC_VERT_2_POINT_$[09P]
    :--------------------------------: $_SRC_FRAG_2_POINT_$[09P]
                                                           [---]
    $_SYMBOLIC_CONST_V_$ :--------------------------------:[10P]
    $_SYMBOLIC_CONST_F_$ :--------------------------------:[10P]
                                                           [10P]
        @_SYMBOLIC_CONST_V_@ : Symbolic constant (number)  [10P]
                             : that means "Vertex Shader". [10P]
                                                           [10P]
        @_SYMBOLIC_CONST_F_@ : Symbolic constant (number)  [10P]
                             : that means "Frag   Shader". [10P]
                                                           [10P]
    :--------------------------------:$_SYMBOLIC_CONST_F_$ [10P]
    :--------------------------------:$_SYMBOLIC_CONST_V_$ [10P]
    #__VER_THEN_FRA__# :----------------------------------:[10P]
                                                          |[10P]
        As we are grouping the different calls ,          |[10P]
        sub-group the calls by "vertex shader"            |[10P]
        stuff first , and "fragment shader stuff"         |[10P]
        second.                                           |[10P]
                                                          |[10P]
        I don't like arbitrary choice , so it seems       |[10P]
        to make sense to me to do the vertex things       |[10P]
        first since "vertex stage" comes before           |[10P]
        "fragment stage" in shader pipeline.              |[10P]
                                                          |[10P]
    :----------------------------------: #__VER_THEN_FRA__#[10P]
                                                           [---]
    #__COMPILE_SHADER__# :--------------------------------:[11P]
                                                          |[11P]
        A wrapper function that compiles the shader       |[11P]
        and then error checks it, we have this wrapper    |[11P]
        function so as to not wreck the flow of the       |[11P]
        code in the[ VER_THEN_FRA ]section after we       |[11P]
        refactor it to use __OUR__ custom compile         |[11P]
        shader wrapper function.                          |[11P]
                                                          |[11P]
      @i_wso@ : INPUT(param) : Webgl_Shader_Object        |[11P]
        @wso@ : Webgl_Shader_Object                       |[11P]
        @sym@ : general use symbolic constant variable    |[11P]
        @bol@ : general use           boolean variable    |[11P]
        @str@ : general use           string  variable    |[11P]
                                                          |[11P]
        [ sym ] : In this function is COMPILE_STATUS sym  |[11P]
        [ bol ] : In this function is COMPILE_STATUS bol  |[11P]
        [ str ] : In this function is ShaderInfoLog  str  |[11P]
                                                          |[11P]
    :--------------------------------: #__COMPILE_SHADER__#[11P]
    $_FAIL_LOG_$ :----------------------------------------:[11P]
                                                          |[11P]
        Denoting that I am logging out a "logging message"|[11P]
        that will hopefully explain why whatever I am     |[11P]
        doing in [ WebGl / OpenGL ] is failing right now. |[11P]
                                                          |[11P]
    :----------------------------------------: $_FAIL_LOG_$[11P]
    $_UR_SHADER_SUCKS_$ :---------------------------------:[11P]
                                                          |[11P]
        Positive words of encouragement to help whoever   |[11P]
        wrote this code get their /f/u/c/k/i/n/g/ act     |[11P]
        together and write some decent god-fearing ,      |[11P]
        church-going respectable code that adheres to     |[11P]
        our traditions of human-readble pronouncable      |[11P]
        names that sound like english.                    |[11P]
                                                          |[11P]
        All hail the church of LegoNamingCamelCaseJavaBullshit !
                                                          |[11P]
        It probably won't happen though. I hear the       |[11P]
        author is completely off their rocker.            |[11P]
        Abbreviates /s/h/i/t/ like it is assembly         |[11P]
        code or something.                                |[11P]
                                                          |[11P]
    :---------------------------------: $_UR_SHADER_SUCKS_$[11P]

    @d_hed@ : data_global(d_) shader common HEADER         [12P]
                                                           [12P]
    $_DO_NOTHING_SHADER_4_NOW_$ :-------------------------:[12P]
                                                          |[12P]
        Before we worry about shader pipeline #2 ,        |[12P]
        we need to get the first rendering pass           |[12P]
        working correctly.                                |[12P]
                                                          |[12P]
        The 1st rendering pass being our placeholder      |[12P]
        tilemap renderer that the sprite renderer is      |[12P]
        going to render on top of.                        |[12P]
                                                          |[12P]
        An empty "void main(){}" is all that is           |[12P]
        required to pass shader compilation.              |[12P]
                                                          |[12P]
    :-------------------------: $_DO_NOTHING_SHADER_4_NOW_$[12P]
    $_GL_FRAG_COLOR_$ :-----------------------------------:[12P]
                                                          |[12P]
        The built-in variable "gl_FragColor" is only      |[12P]
        available in WebGL1. In WebGL2 and in modern      |[12P]
        OpenGL ES versions , it has been deprecated in    |[12P]
        favor of using the output location qualifiers     |[12P]
        in the fragment shader.                           |[12P]
                                                          |[12P]
    :-----------------------------------: $_GL_FRAG_COLOR_$[12P]

    $_PROGRAM_ID_IS_OBJECT_IN_WGL_$ :---------------------:[13P]
    ?_FAKEID_? :------------------------------------------:[13P]
    ?_PID_V_POB_? :---------------------------------------:[13P]
                                                          |[13P]
        "program id" is actually an OBJECT in WebGL .     |[13P]
        When converting WebGL to OpenGL , "program id"    |[13P]
        will be of the correct type. That is why I        |[13P]
        wrote it this way.                                |[13P]
                                                          |[13P]
        @FAKEID@ : It's a "Fake ID" , it's actually a     |[13P]
                 : "program object" , but if there were   |[13P]
                 : OpenGL it would be an Uint32 ID.       |[13P]
                                                          |[13P]
        @PIV_V_POB@ : Program_ID -versus- Program_OBject  |[13P]
                                                          |[13P]
        @pid@ : ............. Program_ID                  |[13P]
        @pob@ : ............. Program_OBJect              |[13P]
        @d_pob: global_Data - Program_OBject              |[13P]
        @d_pid: global_Data - Program_ID                  |[13P]
                                                          |[13P]
        < WEB  GL Conext > . createProgram ===> POB       |[13P]
        < OPEN GL Conext > . createProgram ===> PID       |[13P]
                                                          |[13P]
        Because we are writing our code with the          |[13P]
        intentions of converting it to C99 in the         |[13P]
        future, we are going to call the variable         |[13P]
        by it's C99 name , even though that might         |[13P]
        be confusing because that is __NOT__ it's         |[13P]
        real underlying type in JavaScript.               |[13P]
                                                          |[13P]
        @d_pid@ : Global Program ID , use same name in    |[13P]
                : WEBGL & OPENGL , even though in WEBGL   |[13P]
                : this is actually a "Program Object"     |[13P]
                : rather than a UINT32 Handle.            |[13P]
                                                          |[13P]
    :---------------------------------------: ?_PID_V_POB_?[13P]
    :------------------------------------------: ?_FAKEID_?[13P]
    :---------------------: $_PROGRAM_ID_IS_OBJECT_IN_WGL_$[13P]
    #__ALLOC_PID_ARR__# :---------------------------------:[13P]
                                                          |[13P]
        Allocated PID Array.                              |[13P]
        Allocated Program ID Array.                       |[13P]
                                                          |[13P]
        NOTE : "PID" is actually an object in WEBGL ,     |[13P]
             : "PID" is just a U32 handle in OPENGL .     |[13P]
                                                          |[13P]
    :---------------------------------: #__ALLOC_PID_ARR__#[13P]
    #__PROGRAM_CREATION__# :------------------------------:[13P]
                                                          |[13P]
        Lets create and setup our program so that we      |[13P]
        are ready to invoke our shader each screen        |[13P]
        re-draw.                                          |[13P]
                                                          |[13P]
        Every time the screen is redrawn the callback     |[13P]
        registered with "requestAnimationFrame" will      |[13P]
        be fired, inside that callback we should be       |[13P]
        calling "d_wgl.drawArrays()".                     |[13P]
                                                          |[13P]
        It's kind of weird to say "drawArrays()"          |[13P]
        because that implies we have a vertex array       |[13P]
        to draw, which is typical in __MOST__ render      |[13P]
        pipelines. But we __DONT__ have any arrays        |[13P]
        to draw....                                       |[13P]
                                                          |[13P]
        You can think of "drawArrays" as meaning :        |[13P]
                                                          |[13P]
            Draw the screen with a STRONG RECOMMENDATION  |[13P]
            that you have an array of vertex information  |[13P]
            to render.                                    |[13P]
                                                          |[13P]
        Currently the function drawing our screen is      |[13P]
        the "LOOP_FOREVER" function.                      |[13P]
                                                          |[13P]
    :------------------------------: #__PROGRAM_CREATION__#[13P]
    #__PROGRAM_SELECT__# :--------------------------------:[13P]
                                                          |[13P]
        Select the program to use. For now we are going   |[13P]
        to use the "fake tilemap shader" , eventually     |[13P]
        we actually want to use BOTH PROGRAMS each        |[13P]
        screen redraw. Calling the tilemap shader         |[13P]
        pipeline first to render the tilemap, then        |[13P]
        the point sprite shader pipeline to render        |[13P]
        the sprites on top of the tilemap.                |[13P]
                                                          |[13P]
    :--------------------------------: #__PROGRAM_SELECT__#[13P]

    #__IAM_A_DIRTY_LIAR__# :------------------------------:[14P]
                                                          |[14P]
        I am a dirty liar. Even though we don't need      |[14P]
        a vertex shader for the tilemap renderer...       |[14P]
        We still at least need an __EMPTY__ vertex        |[14P]
        shader to make a valid program object.            |[14P]
                                                          |[14P]
        In Other Words :                                  |[14P]
                                                          |[14P]
                : Valid webgl program object requires ::: |[14P]
                : at minimum a vertex and fragment    ::: |[14P]
                : shader, even if they contain        ::: |[14P]
                : just an empty "void main".          ::: |[14P]
                                                          |[14P]
        $_NO_VERT_LOGIC_IN_TILE_MAP_$ :------------:      |[14P]
                                                   |      |[14P]
            No vertex transformation logic in our  |      |[14P]
            tilemap shader, all we need is an      |      |[14P]
            empty void main. We still must have    |      |[14P]
            a[ void_main ]but is can be empty.     |      |[14P]
                                                   |      |[14P]
        :------------: $_NO_VERT_LOGIC_IN_TILE_MAP_$      |[14P]
                                                          |[14P]
                                                          |[14P]
    :------------------------------: #__IAM_A_DIRTY_LIAR__#[14P]
    #__VIEWPORT_SETUP__# :--------------------------------:[14P]
                                                          |[14P]
        Make sure the webgl context size matches          |[14P]
        the size of our canvas. Eventually we also        |[14P]
        want to make sure the cavas size is always        |[14P]
        the size of our browser's client area.            |[14P]
                                                          |[14P]
        But for now, lets just focus on getting the       |[14P]
        intial 512__X__512 render working.                |[14P]
                                                          |[14P]
    :--------------------------------: #__VIEWPORT_SETUP__#[14P]
    #__ALIGN_CONTEXT_TO_CANVAS__# :-----------------------:[14P]
                                                          |[14P]
        "Align context to canvas" isn't the most accurate |[14P]
        way to describe what we are doing. In more        |[14P]
        accurate terms we are :                           |[14P]
                                                          |[14P]
            Setting the viewport of the WebGL             |[14P]
            rendering context to match the                |[14P]
            dimensions of the canvas.                     |[14P]
                                                          |[14P]
    :-----------------------:#__ALIGN_CONTEXT_TO_CANVAS__#:[14P]

    $_CAP_N_DIA_$ :---------------------------------------:[15P]
                                                          |[15P]
        @BIG_N@ : BIG "N" , literally drawing a big "N"   |[15P]
                : using 4 verts, which can create         |[15P]
                : 2 triangles to cover the entire         |[15P]
                : screen in homogeneous coordinates.      |[15P]
                                                          |[15P]
            +-------+      +-------+                      |[15P]
            |       |      |       |                      |[15P]
            | (0,1) |      | (1,1) |    (#,#)==(v_x,v_y)  |[15P]
            |       |      |       |                      |[15P]
            +---+---+      +---+---+                      |[15P]
                ^    \         ^                          |[15P]
                ^     \        ^                          |[15P]
                ^      \       ^                          |[15P]
                ^       \      ^                          |[15P]
                ^        \     ^                          |[15P]
                ^         \    ^                          |[15P]
            +---+---+      +---+---+                      |[15P]
            |       |      |       |                      |[15P]
            | (0,0) |      | (1,0) |                      |[15P]
            |       |      |       |                      |[15P]
            +-------+      +-------+                      |[15P]
                                                          |[15P]
            The "BIG_N" here is __NOT__ in homogeneous    |[15P]
            coordinates however, so we need to apply      |[15P]
            a formula so that :                           |[15P]
                                                          |[15P]
            ( 0 )====>( -1 )                              |[15P]
            ( 1 )====>( +1 )                              |[15P]
                                                          |[15P]
            +-----------------+-----------------+         |[15P]
            |                 |                 |         |[15P]
            |                                   |         |[15P]
            |                 |                 |         |[15P]
            + - - - - - - -( 0,0 )- - - - - - - +         |[15P]
            |                 |                 |         |[15P]
            |                                   |         |[15P]
            |                 |                 |         |[15P]
            +-----------------+-----------------+         |[15P]
                                                          |[15P]
        In WebGL , a RIGHT handed coordinate system is    |[15P]
        used. This is because /G/U/N/S/ are used with     |[15P]
        your RIGHT_HAND and WebGL is trying to shoot      |[15P]
        you in the face with bullets that have a          |[15P]
        positive forward velocity.                        |[15P]
                                                          |[15P]
        Hope this helps,                                  |[15P]
                                                          |[15P]
        - KanjiCoder                                      |[15P]
                                                          |[15P]
    :---------------------------------------:$_CAP_N_DIA_$:[15P]
    $_1ST_VERT_DEX_$ :------------------------------------:[15P]
                                                          |[15P]
        The index of the first vertex to start drawing.   |[15P]
        I would keep this at ZERO because looks like      |[15P]
        different versions of [WEBGL/OPENGL]don't agree   |[15P]
        on if this value is relative or absolute.         |[15P]
                                                          |[15P]
        But if we keep it at zero , all implementations   |[15P]
        of [OPENGL/WEBGL] will assume first value of      |[15P]
        [ gl_VertexID ]is ZERO(0).                        |[15P]
                                                          |[15P]
    :------------------------------------:$_1ST_VERT_DEX_$:[15P]
    $_NUM_VERT_IDS_$ :------------------------------------:[15P]
                                                          |[15P]
        Total number of verts to draw ,                   |[15P]
        starting at 1ST_VERT_DEX .                        |[15P]
                                                          |[15P]
    :------------------------------------:$_NUM_VERT_IDS_$:[15P]

    $_OCD_I32_$ :-----------------------------------------:[16P]
    $_OCD_U32_$ :-----------------------------------------:[16P]
                                                          |[16P]
        @OCD_I32@ : ObsessiveCompulsiveDisorder -  Int32  |[16P]
        @OCD_U32@ : ObsessiveCompulsiveDisorder - Uint32  |[16P]
                                                          |[16P]
        I like when things line up, and this particular   |[16P]
        difference between signed and un-signed integers  |[16P]
        really bothers me because of how it causes        |[16P]
        my source code to slightly[stagger/mal-align].    |[16P]
                                                          |[16P]
    :-----------------------------------------:$_OCD_U32_$:[16P]
    :-----------------------------------------:$_OCD_I32_$:[16P]
    $_BOARD_$ :-------------------------------------------:[16P]
                                                           [16P]
        We are making a checkerboard. When the X and       [16P]
        Y address of the[ cell/square ]are                 [16P]
                                                           [16P]
            [ BOTH EVEN ]OR[ BOTH ODD ]                    [16P]
                                                           [16P]
        We color the cell[ DARK_GREY ].                    [16P]
                                                           [16P]
        Let's make a quick truth table diagram where       [16P]
        we label all of the cells where odd-even match.    [16P]
                                                           [16P]
        +---------+---------+---------+---------+---------+[16P]
        |  EVE_X  |         |  EVE_X  |         |  EVE_X  |[16P]
        |         |         |         |         |         |[16P]
        |  EVE_Y  |         |  EVE_Y  |         |  EVE_Y  |[16P]
        +---------+---------+---------+---------+---------+[16P]
        |         |  ODD_X  |         |  ODD_X  |         |[16P]
        |         |         |         |         |         |[16P]
        |         |  ODD_Y  |         |  ODD_Y  |         |[16P]
        +---------+---------+---------+---------+---------+[16P]
        |  EVE_X  |         |  EVE_X  |         |  EVE_X  |[16P]
        |         |         |         |         |         |[16P]
        |  EVE_Y  |         |  EVE_Y  |         |  EVE_Y  |[16P]
        +---------+---------+---------+---------+---------+[16P]
        |         |  ODD_X  |         |  ODD_X  |         |[16P]
        |         |         |         |         |         |[16P]
        |         |  ODD_Y  |         |  ODD_Y  |         |[16P]
        +---------+---------+---------+---------+---------+[16P]
        |  EVE_X  |         |  EVE_X  |         |  EVE_X  |[16P]
        |         |         |         |         |         |[16P]
        |  EVE_Y  |         |  EVE_Y  |         |  EVE_Y  |[16P]
        +---------+---------+---------+---------+---------+[16P]
                                                           [16P]
    :-------------------------------------------:$_BOARD_$:[16P]

    [ FUTURE_ORPHAN ] :-----------------------------------:[17P]
                                                          |[17P]
     @FUTURE_ORPHAN_SECTION@ : Section will be orphaned ! |[17P]
                                                          |[17P]
            A comment section that will eventually __NOT__|[17P]
            point to any code in top of file once we move |[17P]
            onto deltas higher than the one the section   |[17P]
            was originally written in.                    |[17P]
                                                          |[17P]
    :-----------------------------------:[ FUTURE_ORPHAN ]:[17P]
    $__NEXT_VIDEO_SPRITE_LOGIC__$ :-----------------------:[17P]
                                                          |[17P]
        @FUTURE_ORPHAN_SECTION@                           |[17P]
                                                          |[17P]
        We already wrote too much code in delta #17(17P). |[17P]
        We will insert code for sprite size and           |[17P]
        position here in the next [video/delta].(#18(18P))|[17P]
                                                          |[17P]
    :-----------------------:$__NEXT_VIDEO_SPRITE_LOGIC__$:[17P]
    $_SPRITE_FC_$ :---------------------------------------:[17P]
                                                          |[17P]
        The sprite fragment color , named "sfc" to        |[17P]
        differentiate itself from the "f_c" in the        |[17P]
        tilemap shader. Eventually we need to refactor    |[17P]
        "f_c" to "tfc" because :                          |[17P]
                                                          |[17P]
        BAD_DESIGN :                                      |[17P]
            f_c IMPLIES  TILEMAP's FRAG_COLOR             |[17P]
            sfc EXPLICIT SPRITE's  FRAG_COLOR             |[17P]
                                                          |[17P]
        GOOD_DESIGN:                                      |[17P]
            tfc EXPLICIT TILEMAP's FRAG_COLOR             |[17P]
            sfc EXPLICIT SPRITE's  FRAG_COLOR             |[17P]
                                                          |[17P]
        @f_c@ : Fragment_Color , generic.                 |[17P]
        @tfc@ : Tilemap_Fragment_Color                    |[17P]
        @sfc@ : Sprite__Fragment_Color                    |[17P]
                                                          |[17P]
    :---------------------------------------:$_SPRITE_FC_$:[17P]
    #__SPRITES_ON_TOP__# :--------------------------------:[17P]
                                                          |[17P]
        Render the sprites on top of the tilemap with     |[17P]
        a 2nd draw call. To start off we will just        |[17P]
        render the sprites as points, and eventually      |[17P]
        we will re-factor to use a player sprite.         |[17P]
                                                          |[17P]
        But... One step at a time my friends.             |[17P]
                                                          |[17P]
    :--------------------------------:#__SPRITES_ON_TOP__#:[17P]
                                                           [---]
    @d_p2k@ : global_Data(d_) - Pixels 2,000 (2048_X_2048) [18P]
    @SID@ ::: Sprite_ID                                    [18P]
                                                           [18P]
    $_Sprite_NDC_X_$ :------------------------------------:[18P]
    $_Sprite_NDC_Y_$ :------------------------------------:[18P]
                                                          |[18P]
        @Sprite_NDC_X@ : Sprite_Normalized_Device_Coords.X|[18P]
        @Sprite_NDC_Y@ : Sprite_Normalized_Device_Coords.Y|[18P]
                                                          |[18P]
        @NDC@ : Normalized_Device_Coordinates.            |[18P]
              : NDC are in range : (-1.0 to +1.0)         |[18P]
                                                          |[18P]
    :------------------------------------:$_Sprite_NDC_Y_$:[18P]
    :------------------------------------:$_Sprite_NDC_X_$:[18P]

    #__UNIFORM_INIT__# :----------------------------------:[19P]
                                                          |[19P]
        Set intial values for all of our uniforms.        |[19P]
        They are called "uniforms" because they have      |[19P]
        a "uniform value" for every invokation of         |[19P]
        the shader for a given game frame.                |[19P]
                                                          |[19P]
    :----------------------------------:#__UNIFORM_INIT__#:[19P]
    #__UNIFORM_ADDRESSES__# :-----------------------------:[19P]
                                                          |[19P]
        Get the addresses of our uniform variables within |[19P]
        our shader objects. We can't get a real raw       |[19P]
        [ pointer / address ] so instead we get a thing   |[19P]
        called a "location" which is just OpenGL's        |[19P]
        name for an "Integer Handle".                     |[19P]
                                                          |[19P]
        @GUL@ ::::::: Get_Uniform_Location (FUNCTION_PTR) |[19P]
        @d_tik_loc@ : game ticker's (tik) location (loc)  |[19P]
                                                          |[19P]
        WARNING : WebGL And OpenGL __DIFFER__ here :      |[19P]
                                                          |[19P]
        Uniform Locations Are :                           |[19P]
                                                          |[19P]
            OPENGL : INTEGER HANDLES                      |[19P]
            WEBGL  : WebGLUniformLocation Objects         |[19P]
                                                          |[19P]
    :-----------------------------:#__UNIFORM_ADDRESSES__#:[19P]
    #__GAME_STATE_UPDATE__# :-----------------------------:[19P]
                                                          |[19P]
        Any game logic that needs to be updated will      |[19P]
        go into this "game state update" section.         |[19P]
                                                          |[19P]
        @d_tik@ : global_Data(d_) - game TIcKer(time)     |[19P]
                                                          |[19P]
        We are not going to add any new functions to      |[19P]
        this project unless ABSOLUTELY NECESSARY because  |[19P]
        fractionating the code base like that turns our   |[19P]
        code into spaghetti code and fucks with our       |[19P]
        "linear narrative".                               |[19P]
                                                          |[19P]
        Linear Narrative Reference :                      |[19P]
                                                          |[19P]
            www.youtube.com/watch?v=Nb2tebYAaOA&t=8m30s   |[19P]
                                                          |[19P]
            AT EXACTLY 8 minutes and 30 Seconds.          |[19P]
            Lex Fridman interviews Jim Keller .           |[19P]
            A micro-processor engineer.                   |[19P]
                                                          |[19P]
    :-----------------------------:#__GAME_STATE_UPDATE__#:[19P]
    #__ATOMIC_IVY_MMO_GLOBALS__# :------------------------:[20P]
                                                          |[20P]
        Global variable's who's EXACT NAME and usage      |[20P]
        appear in "ATOMIC_IVY_MMO.JS" here :              |[20P]
                                                          |[20P]
            www.github.com/KanjiCoder/AIM                 |[20P]
                                                          |[20P]
        We want to isolate these globals from other       |[20P]
        globals in order to make it easier to know        |[20P]
        what we will be taking from this "POI" project    |[20P]
        and pasting into the new "ARTEMIS" system of      |[20P]
        "Atomic Ivy MMO" once this mini-sprite-renderer   |[20P]
        project has been completed.                       |[20P]
                                                          |[20P]
    :------------------------:#__ATOMIC_IVY_MMO_GLOBALS__#:[20P]
    #__PLAYER_CONTROL__# :--------------------------------:[20P]
                                                          |[20P]
        @i_kev@ : Input(i_) - Keyboard_EVent(object)      |[20P]
          @kev@ :             Keyboard_EVent(object)      |[20P]
                                                          |[20P]
        A simple keyboard controller that can move the    |[20P]
        active player will go here. I think we will       |[20P]
        make it so that pressing "1,2,3,4,5,6,7,8,9"      |[20P]
        on the keyboard will give you control of players  |[20P]
        1-9 . Then we can put 9 sprites on screen.        |[20P]
                                                          |[20P]
        Then you can use the arrow keys to move the       |[20P]
        player's position around the tilemap.             |[20P]
                                                          |[20P]
    :--------------------------------:#__PLAYER_CONTROL__#:[20P]
    #__WIREUP_KEYBOARD__# :-------------------------------:[20P]
                                                          |[20P]
        Register the  [ PLAYER_CONTROL ]  function with   |[20P]
        a keyboard event so that the  [ PLAYER_CONTROL ]  |[20P]
        function is allways "Called Back" when keys       |[20P]
        on the keyboard are pressed by the user.          |[20P]
                                                          |[20P]
    :-------------------------------:#__WIREUP_KEYBOARD__#:[20P]
    $_CPU_PIX2048_AND_GPU_P2K_$ :-------------------------:[20P]
                                                          |[20P]
        "p2k" is "pix2048" .                              |[20P]
                                                          |[20P]
        CPU_SIDE_TEXTURE_NAME === "pix2048" ( bitmap  )   |[20P]
        GPU_SIDE_TEXTURE_NAME === "p2k"     ( sampler )   |[20P]
                                                          |[20P]
        One of the few uniforms in my engine that break   |[20P]
        the rules of "same name on CPU as GPU".           |[20P]
                                                          |[20P]
        @d_pix2048@ : A 2048_X_2048 bitmap that stores    |[20P]
          @pix2048@ : all the memory for entire game.     |[20P]
                                                          |[20P]
            @d_p2k@ : A texture sampler for the GPU       |[20P]
              @p2k@ : side texture version of             |[20P]
                    : [ d_pix2048 ].                      |[20P]
                                                          |[20P]
    :-------------------------:$_CPU_PIX2048_AND_GPU_P2K_$:[20P]
                                                           [---]
    #__INIT_CPU_TEXTURE__# :------------------------------:[21P]
                                                          |[21P]
        Initialize the CPU-side texture that is used for  |[21P]
        the game's master memory. A small sub-chunk of    |[21P]
        these pixels will be decidated to sprite          |[21P]
        information.                                      |[21P]
                                                          |[21P]
        The main game ( ATOMIC_IVY_MMO.JS ) is designed   |[21P]
        to have a maximum of 64 sprites. These sprites    |[21P]
        can be NPC or PLAYER sprites. But the total       |[21P]
        cannot go over 64. So for example :               |[21P]
                                                          |[21P]
        You could have :                                  |[21P]
                                                          |[21P]
            1.  64 Players , 00 NPCS ( 64 Total Sprites ) |[21P]
            2.  00 Players , 64 NPCS ( 64 Total Sprites ) |[21P]
            3.  32 Players , 32 NPCS ( 64 Total Sprites ) |[21P]
                                                          |[21P]
        Or any balancing between ( 1.) and ( 2.) in       |[21P]
        the examples given above.                         |[21P]
                                                          |[21P]
        We are going to fill this CPU-side bitmap with    |[21P]
        bogus data for now. We don't really care what     |[21P]
        is in it at the moment, but we would like         |[21P]
        adjacent pixels and bytes to store something      |[21P]
        different so that hopefully when our sprites      |[21P]
        are reading their respective chunks of bogus      |[21P]
        intialized data, they will all do something       |[21P]
        visually different that the other.                |[21P]
                                                          |[21P]
    :------------------------------:#__INIT_CPU_TEXTURE__#:[21P]

    #__ALLOC_GPU_TEXTURE__# :-----------------------------:[22P]
                                                          |[22P]
        Allocate(ALLOC) the GPU-side texture memory.      |[22P]
        This GPU-side memory is going to be a direct      |[22P]
        analog to the CPU-side[ d_pix2048 ]bitmap.        |[22P]
                                                          |[22P]
        It is an UN-signed 32-bit integer texture         |[22P]
        with 8-bits per color channel. The bytes          |[22P]
        stored in order[ R,G,B,A ]for                     |[22P]
        [ RED,GREEN,BLUE,ALPHA] respectively.             |[22P]
                                                          |[22P]
        THAT_EXACT_FUCKING_ORDER!!                        |[22P]
                                                          |[22P]
        Unsigned integer textures are only supported      |[22P]
        in WebGL2 , so if you __DONT__ have a webgl2      |[22P]
        context, this code __WILL_NOT_WORK__ !            |[22P]
                                                          |[22P]
        $_T_O_T_$ : Type_Of_Texture , In webgl            |[22P]
                  : this is known as "Texture Target"     |[22P]
                                                          |[22P]
        $_T_HAN_$ : Texture_HANdle , in webgl this is     |[22P]
                  : a[ WebGLTexture ]object.              |[22P]
                  :                                       |[22P]
                  : If this were OPENGL ,                 |[22P]
                  : we would use                          |[22P]
                  : [ glGenTextures ]instead of           |[22P]
                  : [ d_wgl.createTexture ]and get        |[22P]
                  : back an integer handle instead        |[22P]
                  : of an object.                         |[22P]
                                                          |[22P]
        $_L_O_D_$ : Level_Of_Detail , a zero here         |[22P]
                  : means "mip map level 0" which         |[22P]
                  : means "full resolution texture".      |[22P]
                                                          |[22P]
                                                          |[22P]
        $_C_FMT_$ :---------------------------------:     |[22P]
                                                    |     |[22P]
            @C_FMT@ : CPU-side FORMAT of PIXEL_DATA.|     |[22P]
                                                    |     |[22P]
        :---------------------------------: $_C_FMT_$     |[22P]
        $_G_FMT_$ :---------------------------------:     |[22P]
                                                    |     |[22P]
            YES!!! TWO INPUTS ARE TAGGED WITH THIS  |     |[22P]
                   BECAUSE COLLECTIVELY THEY MAKE   |     |[22P]
                   UP THE[ GPU_FORMAT ]!!!!!!!!!!!  |     |[22P]
                                                    |     |[22P]
            @G_FMT@ : GPU-side FORMAT of PIXEL_DATA.|     |[22P]
                                                    |     |[22P]
                    : Technically on GPU it is      |     |[22P]
                    : called "Texel Data".          |     |[22P]
                                                    |     |[22P]
        :---------------------------------: $_G_FMT_$     |[22P]
        [ T_I_2_D ] :-------------------------------:     |[22P]
                                                    |     |[22P]
            Just marking the scope of the           |     |[22P]
            [ texImage2D ]call, because it is       |     |[22P]
            a pretty verbose call with a lot of     |     |[22P]
            [ actual arguments ]to keep track of.   |     |[22P]
                                                    |     |[22P]
            Formal_Params : Part of func prototype  |     |[22P]
            Actual_Args   : Actual data passed in   |     |[22P]
                                                    |     |[22P]
        :-------------------------------:[ T_I_2_D ]:     |[22P]
                                                          |[22P]
    :-----------------------------:#__ALLOC_GPU_TEXTURE__#:[22P]
    #__ATOMIC_IVY_MMO_CONSTANTS__# :----------------------:[23P]
                                                          |[23P]
        Constants in this section should have identical   |[23P]
        names to their counterparts in my main            |[23P]
        __OPEN_SOURCE_MMO_CODE_BASE__ known as            |[23P]
        "Atomic Ivy MMO". ( @AIM@ : Atomic_Ivy_MMO )      |[23P]
                                                          |[23P]
        www.github.com/KanjiCoder/AIM                     |[23P]
                                                          |[23P]
        Though these are constants, we are declaring      |[23P]
        them with the "let" keyword to keep this          |[23P]
        code base simple. They are constant on the        |[23P]
        honor's system. Don't change them.                |[23P]
                                                          |[23P]
    :----------------------:#__ATOMIC_IVY_MMO_CONSTANTS__#:[23P]
    ?_NICE_GIF_YOU_GOT_THERE_? :--------------------------:[23P]
                                                          :[23P]
        The animated gif featured in my youtube           :[23P]
        short tutorial video( [POI_023] )                 :[23P]
        is here[     imgur.com/a/usjiEW7 ]IMGUR_URL       :[23P]
        TINYURL[ www.tinyurl.com/AIM-GIF ]TINY__URL       :[23P]
                                                          :[23P]
    :--------------------------:?_NICE_GIF_YOU_GOT_THERE_?:[23P]
    
    #_TEX_UNI_IND_P2K_# :---------------------------------:[24P]
                                                          |[24P]
        @TEX_UNI_IND_P2K@ : Texture Unit Index Of - d_p2k |[24P]
                                                          |[24P]
        We use this index to do TWO THINGS :              |[24P]
                                                          |[24P]
        1. Correctly setup our texture to correct T_S_I   |[24P]
        2. Correctly setup our sampler to correct T_U_I   |[24P]
                                                          |[24P]
        @T_U_I@ : Texture_Unit_Index ( Local  Index )     |[24P]
        @T_S_I@ : Texture_Slot_Index ( Global Index )     |[24P]
                                                          |[24P]
        Fairly certain the sampler needs to use the       |[24P]
        [ local_index ]( T_U_I )while texture uploading   |[24P]
        needs to use the[ global_index ] ( T_S_I ).       |[24P]
                                                          |[24P]
                                                          |[24P]
    :---------------------------------:#_TEX_UNI_IND_P2K_#:[24P]
    #_ACTIVATE_B4_BIND_# :--------------------------------:[24P]
                                                          |[24P]
        @ACTIVATE_B4_BIND@ : Activate Before Bind         |[24P]
                                                          |[24P]
        If we want our uploaded bitmap( d_pix2048 )       |[24P]
        to have settings that agree with the uploaded     |[24P]
        bitmap's sampler ( d_p2k ) , then we need         |[24P]
        to make sure the below things are equal :         |[24P]
                                                          |[24P]
        1. d_pix2048's active texture unit upon           |[24P]
           upload should be equal to integer value        |[24P]
           uploaded to[ d_p2k ]texture sampler.           |[24P]
                                                          |[24P]
        2. d_2pk 's texture sampler should be loaded      |[24P]
           with the same relative "texture_unit_index"    |[24P]
           that was in focus when we upload[ d_pix2048 ]. |[24P]
                                                          |[24P]
        A texture sampler is just an integer uniform.     |[24P]
        That is all it is. If you are used to             |[24P]
        Object_Oriented_Programming( OOP ), that might    |[24P]
        feel kind of weird.                               |[24P]
                                                          |[24P]
        But think about it... Our texture sampler only    |[24P]
        has ONE_PIECE_OF_INFORMATION_IT_NEEDS_CONFIGURED  |[24P]
        and that is the "texture_unit_to_sample_from"...  |[24P]
                                                          |[24P]
        So... why would you create an object that only    |[24P]
        has one member variable, which is a number...     |[24P]
        Rather than just... I don't know...               |[24P]
                                                          |[24P]
        USE_A_FUCKING_NUMBER ?                            |[24P]
                                                          |[24P]
        OpenGL / WebGL uses a number in this case.        |[24P]
                                                          |[24P]
        Be a gigachad. Be like WebGL and OpenGL.          |[24P]
                                                          |[24P]
    :--------------------------------:#_ACTIVATE_B4_BIND_#:[24P]
    #__WIRE_UP_SAMPLER__# :-------------------------------:[24P]
                                                          |[24P]
        Set the integer value of "d_p2k" texture          |[24P]
        sampler within our sprite renderer's vertex       |[24P]
        shader by giving command :                        |[24P]
                                                          |[24P]
             d_wgl.uniform1i                              |[24P]
                                                          |[24P]
        Two pieces of information :                       |[24P]
                                                          |[24P]
            1. Address of "d_p2k" in shader (d_p2k_loc)   |[24P]
            2. Value to store in "d_2pk" :  (d_tui_p2k)   |[24P]
                                                          |[24P]
    :-------------------------------:#__WIRE_UP_SAMPLER__#:[24P]

    $_COL_SPRITE_$ :--------------------------------------:[25P]
                                                          |[25P]
        SID  SID  SID  SID  ( Sprite ID Controls Column ) |[25P]
         V    V    V    V   ( Each Sprite's Data Is     ) |[25P]
        [0]  [1]  [2]  [3]  ( Encoded Into a COLUMN ,   ) |[25P]
        [ ]  [ ]  [ ]  [ ]  ( not a row.                ) |[25P]
        [ ]  [ ]  [ ]  [ ]                                |[25P]
        [ ]  [ ]  [ ]  [ ]                                |[25P]
        [ ]  [ ]  [ ]  [ ]                                |[25P]
        [ ]  [ ]  [ ]  [ ]                                |[25P]
                                                          |[25P]
    :--------------------------------------:$_COL_SPRITE_$:[25P]
    $_ROW_ATTRIB_$ :--------------------------------------:[25P]
                                                          |[25P]
         +--+--+--+----- Row Controls Sprite_ID( SID )    |[25P]
         |  |  |  |                                       |[25P]
         V  V  V  V                                       |[25P]
        [ ][ ][ ][ ] <-- Attribute #1 of ALL_SPRITES      |[25P]
                                                          |[25P]
        [ ][ ][ ][ ] <-- Attribute #2 of ALL_SPRITES      |[25P]
                                                          |[25P]
        [ ][ ][ ][ ] <-- Attribute #3 of ALL_SPRITES      |[25P]
                                                          |[25P]
        [ ][ ][ ][ ] <-- Attribute #4 of ALL_SPRITES      |[25P]
                                                          |[25P]
    :--------------------------------------:$_ROW_ATTRIB_$:[25P]

    #__CONSTANTS__# :-------------------------------------:[26P]
                                                          |[26P]
        Constants section for constants that are          |[26P]
        __UNIQUE__ to this __POI__ side project.          |[26P]
                                                          |[26P]
        If the constant also appears in the main          |[26P]
        "ATOMIC_IVY_MMO.JS" source file of our main       |[26P]
        game engine project, the constant belongs in      |[26P]
        the other constant section:                       |[26P]
                                                          |[26P]
                       CONSTANTS : Only exist in POI_###.HTM [_]
        ATOMIC_IVY_MMO_CONSTANTS : Exist in main game engine [_]
                                                          |[26P]
    :-------------------------------------:#__CONSTANTS__#:[26P]
    #__HACK_CPU_TEXTURE__# :------------------------------:[26P]
                                                          |[26P]
        Something is wrong with our texture sampling or   |[26P]
        our texture upload, we need to :                  |[26P]
                                                          |[26P]
            ISOLATE_THE_PROBLEM                           |[26P]
                                                          |[26P]
        If changing every single byte of our texture      |[26P]
        results in the sprites moving from the LEFT_SIDE  |[26P]
        to the RIGHT_SIDE of the screen, then we know     |[26P]
        that we might just for some reason have a         |[26P]
        BIG_CO_INCIDENCE on our hands and everything      |[26P]
        is O_K_A_Y .                                      |[26P]
                                                          |[26P]
        But if that doesn't happen, we need to go         |[26P]
        __BUG_HUNTING__ .                                 |[26P]
                                                          |[26P]
    :------------------------------:#__HACK_CPU_TEXTURE__#:[26P]
    $_BAD_MAX_DEX_$ :-------------------------------------:[26P]
                                                          |[26P]
        We failed to correctly calculate the maximum      |[26P]
        valid byte index for the bitmap we are trying     |[26P]
        to populate with nothing but "0xFF" (255) bytes.  |[26P]
                                                          |[26P]
    :-------------------------------------:$_BAD_MAX_DEX_$:[26P]
    #__UNIFORM_ADDR_CHK__#:[27P]:-------------------------:[27P]
                                                          |[27P]
        WEBGL : Uniform Handle Is A  FUCKING OBJECT.      |[27P]
        OPENGL: Uniform Handle Is An INTEGER.             |[27P]
                                                          |[27P]
        The reason I have that logging message in         |[27P]
        addition to error checks is just a sanity check.  |[27P]
        I don't feel comfortable with a direct check      |[27P]
        against "null". But that's what we have to do     |[27P]
        in WebGL.                                         |[27P]
                                                          |[27P]
    -------------------------:#__UNIFORM_ADDR_CHK__#:[27P]:[27P]
    #__PARAM_AND_STORE__# :-------------------------------:[27P]
                                                          |[27P]
        @PARAM_AND_STORE@ : Parameters And Storage        |[27P]
                                                          |[27P]
        I am 99% certain that our texture upload is       |[27P]
        now working properly and that the current         |[27P]
        problem we have now is with either our :          |[27P]
                                                          |[27P]
            1. Texel Fetch                                |[27P]
            2. Texel Fetch Bitpacking In Vertex Shader    |[27P]
            3. Texel Fetch Formula To Get NDC.XY Coords   |[27P]
                                                          |[27P]
        @NDC@ : Normalized_Device_Coordinates             |[27P]
                                                          |[27P]
    :-------------------------------:#__PARAM_AND_STORE__#:[27P]

    #__NPC_RENDERER_VERT__# :-----------------------------:[28P]
                                                          |[28P]
        The "NPC Renderer"(*S) vertex shader code.        |[28P]
        THe "NPC Renderer" is also the "PC Renderer".     |[28P]
                                                          |[28P]
        ONE_SHADER_TO_RENDER_ALL_THE_CHARACTERS           |[28P]
        ONE_SHADER_TO_RENDER_ALL_THE_SPRITES              |[28P]
        ONE_SHADER_TO_RENDER_ALL_THE_PLAYERS              |[28P]
        ( Playable and non-playable characters )          |[28P]
        ( Playable and non-playable sprites    )          |[28P]
        ( Playable and non-playable players    )          |[28P]
                                                          |[28P]
    :-----------------------------:#__NPC_RENDERER_VERT__#:[28P]
    #__NPC_RENDERER_FRAG__# :-----------------------------:[28P]
                                                          |[28P]
        The "NPC Renderer"(*S) fragment shader code.      |[28P]
        THe "NPC Renderer" is also the "PC Renderer".     |[28P]
                                                          |[28P]
        ONE_SHADER_TO_RENDER_ALL_THE_CHARACTERS           |[28P]
        ONE_SHADER_TO_RENDER_ALL_THE_SPRITES              |[28P]
        ONE_SHADER_TO_RENDER_ALL_THE_PLAYERS              |[28P]
        ( Playable and non-playable characters )          |[28P]
        ( Playable and non-playable sprites    )          |[28P]
        ( Playable and non-playable players    )          |[28P]
                                                          |[28P]
    :-----------------------------:#__NPC_RENDERER_FRAG__#:[28P]

    #_MARIONETTE_# :--------------------------------------:[29P]
                                                          |[29P]
        @d_marione@ : The active player being controlled  |[29P]
                    : by the[ human-player / client ].    |[29P]
                    : Called "marione" for "marionette".  |[29P]
                                                          |[29P]
        I guess "marione" is an anime character from a    |[29P]
        anime called "hunter-x-hunter". Good enough for   |[29P]
        me, we will use this name in code to refere       |[29P]
        to the client-side-player-index in control        |[29P]
        by the player.                                    |[29P]
                                                          |[29P]
    :--------------------------------------:#_MARIONETTE_#:[29P]
    $_OFFSETRAWX_$ :--------------------------------------:[29P]
    $_OFFSETRAWY_$ :--------------------------------------:[29P]
                                                          |[29P]
        @d_orx@ : Offset_Raw_X ( scalar __NOT__ applied ) |[29P]
        @d_ory@ : Offset_Raw_Y ( scalar __NOT__ applied ) |[29P]
                                                          |[29P]
        The raw offset to move the selected player        |[29P]
        this frame of game. The selected player is        |[29P]
        known as the "Marionette" aka "MARIONE"           |[29P]
        in our code.                                      |[29P]
                                                          |[29P]
        It is the player currently under control          |[29P]
        of the human using the client instance of         |[29P]
        our MMO game engine.                              |[29P]
                                                          |[29P]
        The "MARIONE" is __NEVER__ an __NPC__   .         |[29P]
        THe "MARIONE" is __ALWAYS__ a __HUMAN__ .         |[29P]
                                                          |[29P]
    :--------------------------------------:$_OFFSETRAWY_$:[29P]
    :--------------------------------------:$_OFFSETRAWX_$:[29P]
    #__CHOOSE_PLAYER__# :---------------------------------:[29P]
                                                          |[29P]
        Use the number keys on querty keypad to select    |[29P]
        which player the [ human ]should control. The     |[29P]
        player that the human controls is known as        |[29P]
        the[ MARIONETTE / MARIONE ].                      |[29P]
                                                          |[29P]
    :---------------------------------:#__CHOOSE_PLAYER__#:[29P]
    #__PLAYER_OFFSET_RAW__# :-----------------------------:[29P]
                                                          |[29P]
        Calculate the __RAW__ offset to apply to the      |[29P]
        active player ( MARIONE / MARIONETTE ) this       |[29P]
        frame of the game.                                |[29P]
                                                          |[29P]
        This value will be scaled to something that       |[29P]
        will be noticable. I don't know what that         |[29P]
        scalar will be yet.                               |[29P]
                                                          |[29P]
    :-----------------------------:#__PLAYER_OFFSET_RAW__#:[29P]
    $_BYTE_EXTRACTION_LOGIC_$ :---------------------------:[30P]
    ?_ANOTHER_WAY_TO_SHIFT_? :----------------------------:[30P]
                                                          |[30P]
        How I am extracting bytes in this tutorial :      |[30P]
                                                          |[30P]
        s_m[ dpc + 0 ]=(sav & 0xFF000000) >>> 24 ;        |[30P]
        s_m[ dpc + 1 ]=(sav & 0x00FF0000) >>> 16 ;        |[30P]
        s_m[ dpc + 2 ]=(sav & 0x0000FF00) >>>  8 ;        |[30P]
        s_m[ dpc + 3 ]=(sav & 0x000000FF) >>>  0 ;        |[30P]
                                                          |[30P]
        Another way you might see it done :               |[30P]
                                                          |[30P]
        s_m[ dpc + 0 ]=((sav >>> 24) & 0xFF )>>>0;        |[30P]
        s_m[ dpc + 1 ]=((sav >>> 16) & 0xFF )>>>0;        |[30P]
        s_m[ dpc + 2 ]=((sav >>>  8) & 0xFF )>>>0;        |[30P]
        s_m[ dpc + 3 ]=((sav >>>  0) & 0xFF )>>>0;        |[30P]
                                                          |[30P]
    :----------------------------:?_ANOTHER_WAY_TO_SHIFT_?:[30P]
    :---------------------------:$_BYTE_EXTRACTION_LOGIC_$:[30P]
    #_CPU_UPDATE_PLAYER_# :-------------------------------:[30P]
                                                          |[30P]
        Update of the player on the CPU-SIDE .            |[30P]
                                                          |[30P]
        The flow of information is 1-way here.            |[30P]
        We modify CPU-side memory and then push           |[30P]
        the modifications up to the GPU to sync           |[30P]
        the changes.                                      |[30P]
                                                          |[30P]
        In the next video( PROBABLY_NEXT ) , we will      |[30P]
        upload the CPU-side bitmap changes to the         |[30P]
        corresponding texture memory.                     |[30P]
                                                          |[30P]
    :-------------------------------:#_CPU_UPDATE_PLAYER_#:[30P]

    #_GPU_UPDATE_PLAYER_# :-------------------------------:[31P]
                                                          |[31P]
        Update the player on GPU side by updating the     |[31P]
        512_X_512 block of pixel memory corresponding     |[31P]
        to the[ centeral_level_pack ].                    |[31P]
                                                          |[31P]
        __YES__ this is a __WASTEFUL__ operation where    |[31P]
        we are pushing up __MORE__THAN__WE__NEED_TOO__.   |[31P]
                                                          |[31P]
        __HOWEVER__ , this sprite renderer is a prototype |[31P]
        for the "ARTEMIS" system of "ATOMIC_IVY_MMO.JS"   |[31P]
                                                          |[31P]
    :-------------------------------:#_GPU_UPDATE_PLAYER_#:[31P]
    [ S_T_P_M_B ] :---------------------------------------:[31P]
                                                          |[31P]
        @S_T_P_M_B@ : Sub Texture Push My Bitches         |[31P]
        @STPMB@ ::::: Sub Texture Push My Bitches         |[31P]
                                                          |[31P]
        Just labelling scope of function call.            |[31P]
                                                          |[31P]
    :---------------------------------------:[ S_T_P_M_B ]:[31P]
    $_CLP_ORG_$ :-----------------------------------------:[31P]
                                                          |[31P]
        @CLP_ORG@ : Centeral_Level_Pack - ORIGIN          |[31P]
                                                          |[31P]
    :-----------------------------------------:$_CLP_ORG_$:[31P]
    $_CLP_MAG_$ :-----------------------------------------:[31P]
                                                          |[31P]
        @CLP_MAG@ : Centeral_Level_Pack - MAGNITUDE       |[31P]
                                                          |[31P]
    :-----------------------------------------:$_CLP_MAG_$:[31P]
    $_SRC_FMT_$ :-----------------------------------------:[31P]
    $_SRC_TYP_$ :-----------------------------------------:[31P]
                                                          |[31P]
        @SRC_FMT@ : Source Format                         |[31P]
        @SRC_TYP@ : Source Type                           |[31P]
                                                          |[31P]
        Together, these two inputs make up what I call    |[31P]
        the "GPU_FORMAT" / "GPU_FMT". Is that correct     |[31P]
        to say ? I don't know , but the mental model      |[31P]
        seems to be accurate enough for my needs.         |[31P]
                                                          |[31P]
    :-----------------------------------------:$_SRC_TYP_$:[31P]
    :-----------------------------------------:$_SRC_FMT_$:[31P]
    $_CENTER_LEVPACK_X_$ :--------------------------------:[31P]
    $_CENTER_LEVPACK_Y_$ :--------------------------------:[31P]
    $_CENTER_LEVPACK_W_$ :--------------------------------:[31P]
    $_CENTER_LEVPACK_H_$ :--------------------------------:[31P] 
                                                          |[31P]
        @CENTER_LEVPACK_X@ : Centeral Levelpack TopLeft.X |[31P]
        @CENTER_LEVPACK_Y@ : Centeral Levelpack TopLeft.Y |[31P]
                                                          |[31P]
        @CENTER_LEVPACK_W@ : Centeral Levelpack WID_IN_PIX|[31P]
        @CENTER_LEVPACK_H@ : Centeral Levelpack HIG_IN_PIX|[31P]
                                                          |[31P]
        @WID_IN_PIX@ : Width  In Pixels                   |[31P]
        @HIG_IN_PIX@ : Height In Pixels                   |[31P]
                                                          |[31P]
        +--------+ +--------+ +--------+ +--------+ --=-- |[31P]
        |        | |        | |        | |        |   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        +--------+ +--------+ +--------+ +--------+   |   |[31P]
        +--------+ +--------+ +--------+ +--------+   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        |        | | CENLEV | |        | |        |   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        +--------+ +--------+ +--------+ +--------+2048_PX|[31P]
        +--------+ +--------+ +--------+ +--------+   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        +--------+ +--------+ +--------+ +--------+   |   |[31P]
        +--------+ +--------+ +--------+ +--------+   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        |        | |        | |        | |        |   |   |[31P]
        +--------+ +--------+ +--------+ +--------+ --=-- |[31P]
        :                                         :       |[31P]
        |<-------------- 2048_PX ---------------->|       |[31P]
                                                          |[31P]
        The "Centeral Level Pack" ( CENLEV In Diagram )   |[31P]
        is a 512_X_512 block of memory storing the        |[31P]
        centeral levelpack within our 3_X_3 grid of       |[31P]
        levelpacks in ATOMIC_IVY_MMO.JS(*S) renderable    |[31P]
        space.                                            |[31P]
                                                          |[31P]
        When updating sprite postions, we just push       |[31P]
        __ALL_OF_THIS_MEMORY__ rather than worrying       |[31P]
        about the particulars of what has and has         |[31P]
        not changed.                                      |[31P]
                                                          |[31P]
        The reason being that all the computations        |[31P]
        for figuring out exactly what to push ,           |[31P]
        and all of the multiple[ sub_tex_pushes ]         |[31P]
        that would be used... Is __LESS_EFFICIENT__       |[31P]
        than just pushing the __WHOLE_GOD_DAMNED_THING__. |[31P]
                                                          |[31P]
    :--------------------------------:$_CENTER_LEVPACK_H_$:[31P]
    :--------------------------------:$_CENTER_LEVPACK_W_$:[31P]
    :--------------------------------:$_CENTER_LEVPACK_Y_$:[31P]
    :--------------------------------:$_CENTER_LEVPACK_X_$:[31P]

    $_BEL_LOGIC_DOUBLE_CHEK_$ :---------------------------:[33P]
                                                          |[33P]
        @BEL_LOGIC_DOUBLE_CHEK@ :                         |[33P]
                                                          |[33P]
            ByteExtraction Logic Double CHEcK.            |[33P]
                                                          |[33P]
        I commented out one method of bit shifting for    |[33P]
        another and have confirmed __BOTH__ of these      |[33P]
        methods get the __SAME_RESULT__ :                 |[33P]
                                                          |[33P]
        Method 1 :                                        |[33P]
                                                          |[33P]
            s_m[ dpc + 0 ]=(sav & 0xFF000000)>>>24 ;      |[33P]
            s_m[ dpc + 1 ]=(sav & 0x00FF0000)>>>16 ;      |[33P]
            s_m[ dpc + 2 ]=(sav & 0x0000FF00)>>> 8 ;      |[33P]
            s_m[ dpc + 3 ]=(sav & 0x000000FF)>>> 0 ;      |[33P]
                                                          |[33P]
        Method 2 :                                        |[33P]
                                                          |[33P]
            s_m[ dpc + 0 ]=((sav>>>24)&(0xFF))>>>0 ;      |[33P]
            s_m[ dpc + 1 ]=((sav>>>16)&(0xFF))>>>0 ;      |[33P]
            s_m[ dpc + 2 ]=((sav>>> 8)&(0xFF))>>>0 ;      |[33P]
            s_m[ dpc + 3 ]=((sav>>> 0)&(0xFF))>>>0 ;      |[33P]
                                                          |[33P]
    :---------------------------:$_BEL_LOGIC_DOUBLE_CHEK_$:[33P]

    $_MOVE_FASTER_X_$ :-----------------------------------:[34P]
    $_MOVE_FASTER_Y_$ :-----------------------------------:[34P]
                                                          :[34P]
        @MOVE_FASTER_X@ : Move faster on X by scaling.    :[34P]
        @MOVE_FASTER_Y@ : Move faster on Y by scaling.    :[34P]
                                                          :[34P]
        We need a movement speed that is decently         :[34P]
        noticable in our test be project. Note that       :[34P]
        eventually we will want to move our character     :[34P]
        using :                                           :[34P]
                                                          :[34P]
            "velocity" "drag" "acceleration" "gravity"... :[34P]
                                                          :[34P]
        But that is polish for a later day.               :[34P]
                                                          :[34P]
    :-----------------------------------:$_MOVE_FASTER_Y_$:[34P]
    :-----------------------------------:$_MOVE_FASTER_X_$:[34P]

    #_SPRITE_ATTRIBUTE_INDEXES_# :------------------------:[35P]
                                                          |[35P]
        +---------------------------------------+         |[35P]
        |                                       |         |[35P]
        |   Because of space warping that will  |         |[35P]
        |   be done in our main game engine ,   |         |[35P]
        |   we actually need to store the       |         |[35P]
        |   sprite positions natively as 4D     |         |[35P]
        |   addresses . A 2D tile coord and a   |         |[35P]
        |   2D tile internal coordinate.        |         |[35P]
        |                                       |         |[35P]
        |   I call it :                         |         |[35P]
        |       Hellraizer Space Warping        |         |[35P]
        |   or..Hellraiser Space Compression    |         |[35P]
        |                                       |         |[35P]
        |   Whatever, i was inspired by the     |         |[35P]
        |   netflix hellraiser and how they     |         |[35P]
        |   depict the 4TH dimension to make    |         |[35P]
        |   hallways come out of nowhere.       |         |[35P]
        |                                       |         |[35P]
        +---------------------------------------+         |[35P]
                                                          |[35P]
        @S__A__I@ : Sprite_Attribute_Index                |[35P]
        @SAI@ ::::: Sprite_Attribute_Index                |[35P]
                                                          |[35P]
        $_SAI_GTX_$ : S__A__I . Global_Tile_X             |[35P]
        $_SAI_GTY_$ : S__A__I . Global_Tile_Y             |[35P]
                                                          |[35P]
        $_SAI_DIX_$ : S__A__I . Discrete_Internal_X       |[35P]
        $_SAI_DIY_$ : S__A__I . Discrete_Internal_Y       |[35P]
                                                          |[35P]
        $_SAI_VEL_$ : S__A__I . Velocity                  |[35P]
        $_SAI_ACC_$ : S__A__I . Acceleration              |[35P]
        $_SAI_DRA_$ : S__A__I . Drag                      |[35P]
                                                          |[35P]
        $_SAI_CX0_$ : S__A__I . Camera_bounds.X0 ( @LLC@ )|[35P]
        $_SAI_CX1_$ : S__A__I . Camera_bounds.X1 ( @LLC@ )|[35P]
        $_SAI_CY0_$ : S__A__I . Camera_bounds.Y0 ( @LLC@ )|[35P]
        $_SAI_CY1_$ : S__A__I . Camera_bounds.Y1 ( @LLC@ )|[35P]
                                                          |[35P]
        $_SAI_HCX_$ : S__A__I . Hell_Compression.__X__    |[35P]
        $_SAI_HCY_$ : S__A__I . Hell_Compression.__Y__    |[35P]
                                                          |[35P]
                                                          |[35P]
        @_L_L_C_@ : Low_Level_Camera                      |[35P]
         @L_L_C@  : Low_Level_Camera                      |[35P]
         @LLC@    : Low_Level_Camera                      |[35P]
                                                          |[35P]
        TAG[ JUST_LIKE_THE_MARIONETTE ]                   |[35P]
                                                          |[35P]
        @marione@   : Opposite of an NPC (playble char)   |[35P]
        @npc@       : NON-Playable Character              |[35P]
        @player@    : GENERIC[ npc || marione ]           |[35P]
        @character@ : GENERIC[ npc || marione ]           |[35P]
                                                          |[35P]
                                                          |[35P]
    :------------------------:#_SPRITE_ATTRIBUTE_INDEXES_#:[35P]

    #_F32_SSS_# :-----------------------------------------:[36P]
                                                          |[36P]
        In[ Atomic_Ivy_MMO.JS ]this variable is known as :|[36P]
                                                          |[36P]
            [ f32_sss ]( Float32 SpriteScreenSize )       |[36P]
                                                          |[36P]
        In this test bed project this variable is :       |[36P]
                                                          |[36P]
            [ fss ]( Float32_Sprite_Size )                |[36P]
                                                          |[36P]
        The reason is that space is more limited in this  |[36P]
        [ test_bed ]project .                             |[36P]
                                                          |[36P]
    :-----------------------------------------:#_F32_SSS_#:[36P]

    $_D_VPC_$ :-------------------------------------------:[37P]
    $_D_VP0_$ :-------------------------------------------:[37P]
    $_D_VP1_$ :-------------------------------------------:[37P]
                                                          |[37P]
        TAG[ LOW_LEVEL_CAMERA_RECTANGLES    ]             |[37P]
        TAG[ LOW_LEVEL_SELECTION_RECTANGLES ]             |[37P]
                                                          |[37P]
        @d_vpc@ : global_Data - View_Port____Canvas       |[37P]
        @d_vp0@ : global_Data - View_Port____0 ( DESTIN ) |[37P]
        @d_vp1@ : global_Data - View_Port____1 ( SOURCE ) |[37P]
                                                          |[37P]
        @DESTIN@ : Destination , we read data from        |[37P]
                 : [ SOURCE ]and use it to render pixel   |[37P]
                 : [ ON/SCREEN ], the screen is the       |[37P]
                 : destination.                           |[37P]
                                                          |[37P]
        NOTE : [ vpc ]AND[ vp0 ]are in the exact same ::::|[37P]
             : coordinate space. [ vp0 ]is a SUBSET   ::::|[37P]
             : of[ vpc ]coords. We have these __TWO__ ::::|[37P]
             : viewports so that we can implement     ::::|[37P]
             : [ letter_boxing ]of our rendering .    ::::|[37P]
                                                          |[37P]
    :-------------------------------------------:$_D_VP1_$:[37P]
    :-------------------------------------------:$_D_VP0_$:[37P]
    :-------------------------------------------:$_D_VPC_$:[37P]
    $_TILEMAP_VPC_$ :-------------------------------------:[37P]
    $_TILEMAP_VP0_$ :-------------------------------------:[37P]
    $_TILEMAP_VP1_$ :-------------------------------------:[37P]
                                                          |[37P]
        @TILEMAP_VPC@ : Tilemap shader(*S) [ d_vpc ]var.  |[37P]
        @TILEMAP_VP0@ : Tilemap shader(*S) [ d_vp0 ]var.  |[37P]
        @TILEMAP_VP1@ : Tilemap shader(*S) [ d_vp1 ]var.  |[37P]
                                                          |[37P]
        We have 2 shader passes , so it is likely that    |[37P]
        we are going to need to have the same uniform     |[37P]
        names in more than one shader. That is going to   |[37P]
        make things tricky, because we have to do         |[37P]
        [ TWO_UNIFORM_PUSHES ]PER[ UNIFORM ].             |[37P]
                                                          |[37P]
        ( assuming uniform is needed in both the )        |[37P]
        ( [ tile_map_shader ]and the ___________ )        |[37P]
        ( [ point_sprite_shader ] ______________ )        |[37P]
                                                          |[37P]
    :-------------------------------------:$_TILEMAP_VP1_$:[37P]
    :-------------------------------------:$_TILEMAP_VP0_$:[37P]
    :-------------------------------------:$_TILEMAP_VPC_$:[37P]
    $_OCD_UV4_$ :-----------------------------------------:[37P]
                                                          |[37P]
        @OCD_UV4@ : ObsessiveCompulsiveDisorder_UV4       |[37P]
            @UV4@ : Uint_Vec_4 , vector of 4 uint32(s).   |[37P]
                                                          |[37P]
        Our camera rectangles are of this type when       |[37P]
        on the[ GPU_SHADER_SIDE ].                        |[37P]
                                                          |[37P]
    :-----------------------------------------: $_OCD_UV4_$[37P]

    #_TILE_DISCRETE_UNITS_# :-----------------------------:[38P]
                                                          |[38P]
        Constants telling us how many discrete units are  |[38P]
        in different tile sizes. The main game engine     |[38P]
        uses[ power_of_2_tile_sizes ], so this prototype  |[38P]
        will aslo use the same[ power_of_2_tile_sizes ]   |[38P]
        in order to be maximally compatible with my       |[38P]
        main game engine code.                            |[38P]
                                                          |[38P]
    :-----------------------------:#_TILE_DISCRETE_UNITS_#:[38P]

    #_CAMERA_ARRAY_MEMBER_INDEXES_# :---------------------:[39P]
                                                          |[39P]
        Our camera objects are just arrays of 4 Uint32(s).|[39P]
        So in order to "read the member variables" of     |[39P]
        our camera, we need "symbolic constants" for      |[39P]
        the 4 member variables of our camera rectangle.   |[39P]
                                                          |[39P]
        @x_0@ : X_axis_Minimum( 0 === MIN ) , CAM_LEF     |[39P]
              : @CAM_LEF@ : Camera   Left Inclusive Edge  |[39P]
                                                          |[39P]
        @x_1@ : X_axis_Minimum( 1 === MAX ) , CAM_RIG     |[39P]
              : @CAM_RIG@ : Camera  Right Inclusive Edge  |[39P]
                                                          |[39P]
        @y_0@ : Y_axis_Minimum( 0 === MIN ) , CAM_TOP     |[39P]
              : @CAM_TOP@ : Camera    Top Inclusive Edge  |[39P]
                                                          |[39P]
        @y_1@ : Y_axis_Minimum( 1 === MAX ) , CAM_BOT     |[39P]
              : @CAM_BOT@ : Camera Bottom Inclusive Edge  |[39P]
                                                          |[39P]
    :---------------------:#_CAMERA_ARRAY_MEMBER_INDEXES_#:[39P]
    #__CAMERA_CONTROL__# :--------------------------------:[39P]
                                                          |[39P]
        The camera controller. This controller should     |[39P]
        only zoom in and out. The position of the camera  |[39P]
        should be based on where the[ player_in_focus ]   |[39P]
        currently is. ( AKA : The marionette index ).     |[39P]
                                                          |[39P]
    :--------------------------------:#__CAMERA_CONTROL__#:[39P]
    #__KEYBOARD_CONTROL__# :------------------------------:[39P]
                                                          |[39P]
        Rather than directly wiring the player controller |[39P]
        to the event listener, we are going to add a      |[39P]
        bit more indirection now that the code is         |[39P]
        getting a bit more sophisticated.                 |[39P]
                                                          |[39P]
        The "keyboard controller" calls                   |[39P]
        the two "sub controllers" :                       |[39P]
                                                          |[39P]
            1. Player Controller ( F _ PLAYER_CONTROL )   |[39P]
            2. Camera Controller ( F _ CAMERA_CONTROL )   |[39P]
                                                          |[39P]
    :------------------------------:#__KEYBOARD_CONTROL__#:[39P]

    #__RESIZE_CANVAS__# :---------------------------------:[40P]
                                                          |[40P]
        Resize the canvas to match the client area.       |[40P]
        We want a canvas that fits the full screen.       |[40P]
                                                          |[40P]
        $_NCE_$ :-----------------------------------:     |[40P]
                                                    |     |[40P]
            @NCE@ : No_Canvas_Error , you have no   |     |[40P]
                  : canvas object. EVERYONE_PANIC!! |     |[40P]
                                                    |     |[40P]
        :-----------------------------------: $_NCE_$     |[40P]
        [ _CAN_MAG_ ] :-----------------------------:     |[40P]
                                                    |     |[40P]
            @CAN_MAG@ : Canvas_Magnitude            |     |[40P]
                                                    |     |[40P]
            This section of code for canvas         |     |[40P]
            magnitude adjustment. AKA : Resizing    |     |[40P]
            the canvas to match the client area.    |     |[40P]
                                                    |     |[40P]
        :-----------------------------: [ _CAN_MAG_ ]     |[40P]
        [ _VPC_VP0_ ] :-----------------------------:     |[40P]
                                                    |     |[40P]
            @VPC_VP0@ : Viewport_Canvas + ViewPort_0|     |[40P]
                                                    |     |[40P]
            Adjust these two viewports...           |     |[40P]
                                                    |     |[40P]
            We need some type of higher level       |     |[40P]
            camera that has a centerpoint and       |     |[40P]
            zoom level.                             |     |[40P]
                                                    |     |[40P]
            Otherwise, changes to the client area   |     |[40P]
            size will totally corrupt our camera    |     |[40P]
            in ir-recoverable ways.                 |     |[40P]
                                                    |     |[40P]
            @_org_x_@ : Origin X Axis               |     |[40P]
            @_org_y_@ : Origin Y Axis               |     |[40P]
            @_v_wid_@ : Viewport Width  In Pixels   |     |[40P]
            @_v_hig_@ : Viewport Height In Pixels   |     |[40P]
                                                    |     |[40P]
        :-----------------------------: [ _VPC_VP0_ ]     |[40P]
        #__SNAP_VP0_ONTO_VPC__# :-------------------:     |[40P]
                                                    |     |[40P]
            Snap VP0 directly on top of VPC so      |     |[40P]
            they are[ co-incidental ]on all         |     |[40P]
            corners.                                |     |[40P]
                                                    |     |[40P]
            Eventually we will want to inset        |     |[40P]
            VP0 to create cinematic letter boxing.  |     |[40P]
            But for now, we won't be doing that.    |     |[40P]
                                                    |     |[40P]
        :-------------------: #__SNAP_VP0_ONTO_VPC__#     |[40P]
        $_IREC_$ :----------------------------------:     |[40P]
                                                    |     |[40P]
            Making a note that our rectangles are   |     |[40P]
            INCLUSIVE_RECTANGLES( IREC / I_REC ).   |     |[40P]
                                                    |     |[40P]
            @IREC@ : Inclusive_RECtangle            |     |[40P]
                                                    |     |[40P]
        :----------------------------------: $_IREC_$     |[40P]
                                                          |[40P]
    :---------------------------------:#__RESIZE_CANVAS__#:[40P]
    #__NOT_SETUP_YET__# :---------------------------------:[40P]
                                                          |[40P]
        Flag our system as NOT_INITIALIZED( false === 1 ).|[40P]
        The[ RESIZE_CANVAS ]function assumes there is     |[40P]
        __NOT__ a webgl context when the system is        |[40P]
        NOT_INITIALIZED .                                 |[40P]
                                                          |[40P]
    :---------------------------------:#__NOT_SETUP_YET__#:[40P]
    #__HAS_BEEN_SETUP__# :--------------------------------:[40P]
                                                          |[40P]
        Flag the initialized( d _ ini )variable to        |[40P]
        true( true === 1 )once our 1-time setup           |[40P]
        code has ran.                                     |[40P]
                                                          |[40P]
    :--------------------------------:#__HAS_BEEN_SETUP__#:[40P]

    #_GL_VIEWHACK_# :-------------------------------------:[41P]
                                                          |[41P]
        A hackish[ NO_OOP / NOOP ]used to make sure that  |[41P]
        our[ camera_rectangles ]are not[ OPTIMIZED_OUT ]  |[41P]
        of our[ GLSL ]shader by the[ GLSL_COMPILER ].     |[41P]
                                                          |[41P]
        [ GLSL_COMPILER ]LOVES_TO_FUCKING_DO_THAT .       |[41P]
                                                          |[41P]
        So if we want error checks that get thrown when   |[41P]
        we cannot fetch a uniform to pass , we need to    |[41P]
        guarantee these uniforms are in the shader with   |[41P]
        this[ NOOP_HACK ].                                |[41P]
                                                          |[41P]
        @NOOP_HACK@ : NO_OPeration_HACK                   |[41P]
                                                          |[41P]
    :-------------------------------------:#_GL_VIEWHACK_#:[41P]

    #__SNAP_TO_CENTER_____HOTEL_# :-----------------------:[42P]
    #__SNAP_TO_CENTER_LEVELPACK_# :-----------------------:[42P]
                                                          |[42P]
        TAG[ SNAP_TO_CENTER_HOTEL ]                       |[42P]
                                                          |[42P]
        If it is the first-time setup code ,              |[42P]
        then we need to initialize the starting           |[42P]
        point of the camera in the "world space".         |[42P]
                                                          |[42P]
        What data is the camera looking at ?              |[42P]
                                                          |[42P]
        Our renderable space is a 3_X_3 grid of HOTELS.   |[42P]
        So if the[ top_left_corner ]of viewport is        |[42P]
        the magnitude of one hotel, and then we add       |[42P]
        the magnitude of one hotel MINUS ONE to that      |[42P]
        corner, we will get a bottom corner...            |[42P]
                                                          |[42P]
        The top_left + bottom_right corners will create   |[42P]
        an inclusive selection rectangle that is          |[42P]
        EXACTLY_SNAPPED to the HOTEL_IN_THE_DEAD_CENTER . |[42P]
                                                          |[42P]
        |<-------------------[ c_dum ]----------------->| |[42P]
        |<-[ c_duh ]->|  |<-[ c_duh ]->|  |<-[ c_duh ]->| |[42P]
        :             :  :             :  :             : |[42P]
        [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ]  HOTEL  [ ]  [ ]  HOTEL  [ ]  [ ]  HOTEL  [ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][ ] |[42P]
                                                          |[42P]
        [ ][ ][ ][ ][ ]  [A][ ][ ][ ][ ]  [ ][ ][ ][ ][ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ]  HOTEL  [ ]  [ ]  HOTEL  [ ]  [ ]  HOTEL  [ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][B]  [ ][ ][ ][ ][ ] |[42P]
                                                          |[42P]
        [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ]  HOTEL  [ ]  [ ]  HOTEL  [ ]  [ ]  HOTEL  [ ] |[42P]
        [ ]         [ ]  [ ]         [ ]  [ ]         [ ] |[42P]
        [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][ ]  [ ][ ][ ][ ][ ] |[42P]
                                                          |[42P]
        [A] ==TO==> [B] is initial[ d_vp1 ]size.          |[42P]
                                                          |[42P]
        [A].XY =[   c_duh      ,   c_duh      ]           |[42P]
        [B].XY =[ ( c_duh*2)-1 , ( c_duh*2)-1 ]           |[42P]
                                                          |[42P]
    :-----------------------:#__SNAP_TO_CENTER_LEVELPACK_#:[42P]
    :-----------------------:#__SNAP_TO_CENTER_____HOTEL_#:[42P]
                                                           [---]
    #__CALC_SPRITE_SCREEN_SIZE_# :------------------------:[43P]
    #__CALC_SSS__# :--------------------------------------:[43P]
                                                          |[43P]
        Our player is a single 1_X tile's worth of        |[43P]
        discrete units in size. If we know how many       |[43P]
        discrete units are in a single pixel, we can      |[43P]
        figure out the[ gl__point__size ]of the player.   |[43P]
                                                          |[43P]
        The[ gl__point__size ]being the rough number of   |[43P]
        [ fragments / pixels ]needed to render the        |[43P]
        character to the screen.                          |[43P]
                                                          |[43P]
        $_DUN_SEL_$ : DiscreteUNits -in- SELection        |[43P]
                    : The number of discrete units        |[43P]
                    : selected by our off-screen data     |[43P]
                    : selection viewport rectangle .      |[43P]
                    : TAG[ data_selection_viewport_rect ] |[43P]
                                                          |[43P]
        $_MON_PIX_$ : MONitor_PIXels                      |[43P]
                    : The number of pixels selected       |[43P]
                    : by the on-screen pixel selection    |[43P]
                    : viewport rectangle.                 |[43P]
                    : TAG[ pixel_selection_viewport_rect ]|[43P]
                                                          |[43P]
                                                          |[43P]
    :--------------------------------------:#__CALC_SSS__#:[43P]
    :------------------------:#__CALC_SPRITE_SCREEN_SIZE_#:[43P]

    #_DISCRETE_UNITS_CHARACTER_# :------------------------:[44P]
                                                          |[44P]
        The number of[ discrete_units ]in a               |[44P]
        [ character_player / player_character ].          |[44P]
                                                          |[44P]
        ( discrete_units === digital_plank_units  )       |[44P]
        ( discrete_units === digital_planck_units )       |[44P]
                                                          |[44P]
        This is a scalar value because it is the exact    |[44P]
        same amount on the X and Y axis .                 |[44P]
                                                          |[44P]
    :------------------------:#_DISCRETE_UNITS_CHARACTER_#:[44P]
    #__VUF_SPRITE_SIZES__# :------------------------------:[44P]
                                                          |[44P]
        @VUF@ : Vector_______Uint32_______Float32         |[44P]
        @VUF@ : Vector__AND__Uint32__AND__Float32         |[44P]
                                                          |[44P]
        STEP 1 : divide DUC by[ duf ]vector .             |[44P]
        STEP 2 : Point Size Is a 1D value , so to make    |[44P]
               : sure our sprite has enough room to       |[44P]
               : be fully rendered , we need to take      |[44P]
               : the largest of the two values stored     |[44P]
               : in our VECTOR_SPRITE_SIZE ( vss )        |[44P]
        STEP 3 : GLSL expects us to use FLOAT32 for       |[44P]
               : our point size, so we need to cast       |[44P]
               : to float. While we are at it ,           |[44P]
               : might as well add 1_PIXEL of padding     |[44P]
               : to every side of sprite in case we       |[44P]
               : need to do some[ ANTI_ALIASING ]         |[44P]
               : trickery in the future .                 |[44P]
                                                          |[44P]
    :------------------------------:#__VUF_SPRITE_SIZES__#:[44P]

    #__MAP_RENDERER_FRAG__# :-----------------------------:[45P]
                                                           [45P]
        @MAP_RENDERER_FRAG@ : tileMAP renderer FRAG stage. [45P]
                                                           [45P]
        Fragment shader code for our[ TILE_MAP ]shader.    [45P]
                                                           [45P]
            |<----------------[ THE_DUM ]---------------->|   45
            :                                             :   45
    ----=-- +-------------+ +-------------+ +-------------+   45
        |   |     [ ]     | |     [ ]     | |     [ ]     |   45
        |   |  [ ][ ][ ]  | |  [ ][ ][ ]  | |  [ ][ ][ ]  |   45
    h3y : 0 [ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ]   45
        |   |  [ ][ ][ ]  | |  [ ][ ][ ]  | |  [ ][ ][ ]  |   45
        |   |     [ ]     | |     [ ]     | |     [ ]     |   45
    ----=-- +-------------+ +-------------+ +-------------+   45
    ----=-- +-------------+ +-------------+ +-------------+   45
        |   |     [ ]     | |     [ ]     | |     [ ]     |   45
        |   |  [ ][ ][ ]  | |  [ ][ ][ ]  | |  [ ][ ][ ]  |   45
    h3y : 1 [ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ]   45
        |   |  [ ][ ][ ]  | |  [ ][ ][ ]  | |  [ ][ ][ ]  |   45
        |   |     [ ]     | |     [ ]     | |     [ ]     |   45
    ----=-- +-------------+ +-------------+ +-------------+   45
    ----=-- +-------------+ +-------------+ +-------------+   45
        |   |     [ ]     | |     [ ]     | |     [ ]     |   45
        |   |  [ ][ ][ ]  | |  [ ][ ][ ]  | |  [ ][ ][ ]  |   45
    h3y : 2 [ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ]   45
        |   |  [ ][ ][ ]  | |  [ ][ ][ ]  | |  [ ][ ][ ]  |   45
        |   |     [ ]     | |     [ ]     | |     [ ]     |   45
    ----=-- +-------------+ +-------------+ +-------------+   45
            :             : :             : :             :   45
            |             | |             | |             |   45
            |  h3x : 000  | |  h3x : 001  | |  h3x : 001  |   45
            |             | |             | |             |   45
                                                           [45P]
            If the camera is MAXIMUM_ZOOMED_OUT            [45P]
            then this is EVERYTHING_WE_CAN_RENDER !!!      [45P]
                                                           [45P]
            MAXIMUM_ZOOM_OUT === RENDER_ALL_THE_DATA       [45P]
                                                           [45P]
        BRING_ME_EVERYONE : youtube.com/watch?v=74BzSTQCl_c   45
                                                           [45P]
    :-----------------------------:#__MAP_RENDERER_FRAG__#:[45P]
                                                           [---]                                                
    $_OCD_UV2_$ :-----------------------------------------:[46P]
                                                          |[46P]
        @OCD_UV2@ : ObsessiveCompulsiveDisorder _ Uvec2   |[46P]
                                                          |[46P]
        I like all of my types to be EXACTLY_3_LETTERS    |[46P]
        so that it is really easy to align my code.       |[46P]
                                                          |[46P]
    :-----------------------------------------:$_OCD_UV2_$:[46P]
                                                           [---]
    #_GET_DUG_# :-----------------------------------------:[47P]
                                                          |[47P]
        @GET_DUG@ : GET____Discrete_Units_Global          |[47P]
                                                          |[47P]
        @DUG@ : Discrete_Units_Global                     |[47P]
                                                          |[47P]
        Dug is basically our "digital plank unit" address |[47P]
        of a sample point within our renderable space .   |[47P]
                                                          |[47P]
        All[ fragment_addresses / fragment_coords ]       |[47P]
        need to be resolved to[ dug_addressed ]           |[47P]
        in order to know[ what_is_being_rendered ]within  |[47P]
        our[ dum_space / world_space / render_space ]     |[47P]
                                                          |[47P]
    :-----------------------------------------:#_GET_DUG_#:[47P]
                                                           [---]
    $_DUF_E__MV1_D_MV0_$ :--------------------------------:[48P]
    ( duf =  mv1 / mv0 )===( DUF_E__MV1_D_MV0 )           |[48P]
    ( DUF_E__MV1_D_MV0 )===( duf =  mv1 / mv0 )           |[48P]
                                                          |[48P]
                             ++==                   ==++  |[48P]
                             || mag_of_vp( DISCRETE ) ||  |[48P]
    Discrete_Units_Fragment =|| --------------------- ||  |[48P]
                             || mag_of_vp(   PIXELS ) ||  |[48P]
                             ++==                   ==++  |[48P]
                                                          |[48P]
        @mag_of_vp@ : Magnitude_Of_ViewPort               |[48P]
                                                          |[48P]
        For example , if you have a 1x1 pixel viewport    |[48P]
        and the offscreen viewport is selecting a BILLION |[48P]
        discrete units, your( duf === BILLION ).          |[48P]
                                                          |[48P]
        Converse Example :                                |[48P]
                                                          |[48P]
            If you have a BILLION_X_BILLION pixel viewport|[48P]
            and you are selecting 1 discrete unit....     |[48P]
                                                          |[48P]
            Then holy fuck you are[ electron_microscope ] |[48P]
            zoomed in there !!!!!!!!!!!!!!!!!!!!!!!!!!!!! |[48P]
                                                          |[48P]
    :--------------------------------:$_DUF_E__MV1_D_MV0_$:[48P]

    $_DIAGRAM_VFC_$ :-------------------------------------:[49P]
    $_DIA_VFC_$ :-----------------------------------------:[49P]
                                                          |[49P]
        @DIAGRAM_VFC@ : Diagram_Viewport_local_FragCoord  |[49P]
                                                          |[49P]
        [00][01][02][03][04][05][06][07][08][09][10][11]  |[49P]
        [__]                                        [__]  |[49P]
        [__]                                        [__]  |[49P]
        [__]        [03][04][05][06] <--vp1 original[__]  |[49P]
        [__]        [  ]        [  ]                [__]  |[49P]
        [__]        [  ]        [  ]                [__]  |[49P]
        [__]        [  ]        [  ]                [__]  |[49P]
        [__]        [00][01][02][03] <-- @vfc@      [__]  |[49P]
        [__]                                        [__]  |[49P]
        [  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ]  |[49P]
                                                          |[49P]
        VP0's boundaries are defined in terms of the      |[49P]
        actual[ screen / client area ]fragment coords.    |[49P]
                                                          |[49P]
        So to localize a coorindate on viewport[ vp0 ]    |[49P]
        we need to subtract the[ top_left ]corner of      |[49P]
        [ vp0 ]from the[ frag_coord ]we are looking at.   |[49P]
                                                          |[49P]
        Then we will have a[ frag_coord ]mapped into      |[49P]
        the range of[ 0 -to- ( mv0 - 1 ) ]INCLUSIVE.      |[49P]
                                                          |[49P]
    :-----------------------------------------:$_DIA_VFC_$:[49P]
    :-------------------------------------:$_DIAGRAM_VFC_$:[49P]
                                                           [---]
    [ _INI_WTF_ ] :---------------------------------------:[51P]
                                                          |[51P]
        If initialization is neither false( negative )    |[51P]
        or true( positive ), then we end up here.         |[51P]
                                                          |[51P]
        Once you end up here , run outside and scream     |[51P]
        and tell everyone to get inside their doors.      |[51P]
        Ask passerbys if they can call 9-11 for you.      |[51P]
        Then ask to pet their dog.                        |[51P]
                                                          |[51P]
    :---------------------------------------:[ _INI_WTF_ ]:[51P]
                                                           [---]
    #_LINE_DEBUG_HACK_# :---------------------------------:[52P]
                                                          |[52P]
        Draw a vertical and horizontal line out of tiles  |[52P]
        by looking for a range of X & Y axis intercepts.  |[52P]
                                                          |[52P]
        So... I did it... And holy fuck it is...          |[52P]
        WAY_FU_C_KING_OFF from what I expected.           |[52P]
                                                          |[52P]
    :---------------------------------:#_LINE_DEBUG_HACK_#:[52P]
                                                           [---]
    $_OCD_FV4_$ :-----------------------------------------:[53P]
                                                          |[53P]
        @OCD_FV4@ : ObsessiveCompulsiveDisorder_FloatVec4 |[53P]
                  : I like all of my types to be exactly  |[53P]
                  : 3-letters so that my code lines up    |[53P]
                  : nicely.                               |[53P]
                                                          |[53P]
    :-----------------------------------------:$_OCD_FV4_$:[53P]
    $_OCD_FV2_$ :-----------------------------------------:[53P]
                                                          |[53P]
        @OCD_FV2@ : ObsessiveCompulsiveDisorder_FloatVec2 |[53P]
                  : Oops. I meant to create this one, not |[53P]
                  : the[ FV4 ], but we will probably want |[53P]
                  : the[ FV4 ]in the future so I am       |[53P]
                  : keeping it. Try and stop me !         |[53P]
                                                          |[53P]
    :-----------------------------------------:$_OCD_FV2_$:[53P]
    $_BLUEBUG_$ :-----------------------------------------:[53P]
                                                          |[53P]
        Tinting the screen blue if our on-screen          |[53P]
        viewport magnitude has a size that is less        |[53P]
        than or equal to one.                             |[53P]
                                                          |[53P]
        I am seeing this tint right now in this           |[53P]
        code delta[ POI_053.HTM ]... So I think           |[53P]
        we are __NOT_UPLOADING__ "vp0" correctly.         |[53P]
                                                          |[53P]
        @vp0@ : On Screen / Destination Viewport          |[53P]
              : This viewport is measured in pixels.      |[53P]
              : ( pixels === gl_FragCoord(s) )            |[53P]
                                                          |[53P]
        @vp1@ : Off Screen Data Selection Viewport        |[53P]
              : AKA : Source Viewport                     |[53P]
              : This viewport is measured in PLANCK(S).   |[53P]
              : PLANCK(S) === Discrete_Units              |[53P]
                                                          |[53P]
    :-----------------------------------------:$_BLUEBUG_$:[53P]
                                                           [---]
    $__SNAP_VPC_TO_CLIENT__$ :----------------------------:[54P]
                                                          |[54P]
        Snap Viewport_C(VPC) to the client area of        |[54P]
        the screen. VPC == View_Port_Canvas <-- EITHER    |[54P]
                    VPC == View_Port_Client <-- EITHER    |[54P]
                                                          |[54P]
    :----------------------------:$__SNAP_VPC_TO_CLIENT__$:[54P]
    $_A_HOLE_WHERE_MY_CODE_USED_TO_BE_$ :-----------------:[54P]
                                                          |[54P]
        Marking where my code used to be before I         |[54P]
        moved things around. I think my initialization    |[54P]
        code might not be executing the way I think       |[54P]
        it is... And that is why my viewport is           |[54P]
        all fucked.                                       |[54P]
                                                          |[54P]
    :-----------------:$_A_HOLE_WHERE_MY_CODE_USED_TO_BE_$:[54P]

    #_REMOVE_SCROLL_BARS_# :------------------------------:[56P]
                                                          |[56P]
        Remove the annoying[ A___S___S ]scrollbars from   |[56P]
        the window, which is supposed to be an exact      |[56P]
        full-screen-render. We don't need any scroll bars.|[56P]
        Let the[ mother_fucker ]burn !!!!!!!!!!!!!!!!!!!  |[56P]
                                                          |[56P]
    :------------------------------:#_REMOVE_SCROLL_BARS_#:[56P]

    #__HIGH_LEVEL_FOLLOW_CAMERA_UPDATE__# :---------------:[57P]
                                                          |[57P]
        Create a "high-level" (more abstract) camera      |[57P]
        object that "follows the player". This high       |[57P]
        level camera will have a centerpoint that is      |[57P]
        snapped to the player, and then a zoom level      |[57P]
        letting us know how zoomed in or out the          |[57P]
        camera is.                                        |[57P]
                                                          |[57P]
        When we need to render, we need to convert        |[57P]
        the higher level camera's [ zoom + center_origin ]|[57P]
        into the[ low_level ]off_screen[ vp1 ]data        |[57P]
        selection rectangle that tells us what tiles      |[57P]
        to select and render onto the screen.             |[57P]
                                                          |[57P]
    :---------------:#__HIGH_LEVEL_FOLLOW_CAMERA_UPDATE__#:[57P]
    #__SNAP_LOW_LEV_CAM_TO_HIGH_LEV_CAM__# :--------------:[57P]
                                                          |[57P]
        Snap the "low level camera" to the                |[57P]
                 "high level camera".                     |[57P]
                                                          |[57P]
        Or in other words...                              |[57P]
                                                          |[57P]
        Derive the low level camera (vp1) selection       |[57P]
        area from the setting stored inside the high      |[57P]
        level camera.                                     |[57P]
                                                          |[57P]
    :--------------:#__SNAP_LOW_LEV_CAM_TO_HIGH_LEV_CAM__#:[57P]
    #__CAM_UPDATE__# :------------------------------------:[57P]
                                                          |[57P]
        Camera update.                                    |[57P]
        Call this code once per game frame to update      |[57P]
        the camera settings on the[ CPU_SIDE ].           |[57P]
                                                          |[57P]
        The code inside this section is only responsible  |[57P]
        for the[ CPU_SIDE ], it is not responsible for    |[57P]
        pushing that data up to the GPU. If we realize    |[57P]
        we need more[ GPU_SYNCING ]code, put that code    |[57P]
        in it's own section[ UNDER ]this section of code. |[57P]
                                                          |[57P]
    :------------------------------------:#__CAM_UPDATE__#:[57P]
    ?_HIGH_LEVEL_CAMERA_OBJECT_? :------------------------:[57P]
                                                          |[57P]
        @d_cdx@ / @cdx@ : Camera_Discrete_X               |[57P]
        @d_cdy@ / @cdy@ : Camera_Discrete_Y               |[57P]
        @d_czp@ / @czp@ : Camera_Zoom_Percent ( NEG_POS ) |[57P]
                                                          |[57P]
        The high level camera has a position measured     |[57P]
        in[ discrete_units / digital_plank_units ]        |[57P]
        and a[ zoom_percentage / zoom_factor ].           |[57P]
                                                          |[57P]
        Camera_Zoom_Percent(czp) is in the range from     |[57P]
        [ -1.0  _to_  +1.0 ].                             |[57P]
                                                          |[57P]
            +1.0 : Fully Zoomed In  ( hotel fills screen )|[57P]
            -1.0 : Fully Zoomed Out ( 1XTIL fills screen )|[57P]
             0.0 : Neutral Zoom                           |[57P]
                                                          |[57P]
            |<-----------[ vp0 ]----------->|             |[57P]
            :                               :             |[57P]
            +-------------------------------+             |[57P]
            |          +---------+          |             |[57P]
            |          |         |          |             |[57P]
            |          |__HOTEL__|          |             |[57P]
            |          |         |          |             |[57P]
            |          +---------+          |             |[57P]
            +-------------------------------+             |[57P]
                                                          |[57P]
            A hotel is square, but the screen is          |[57P]
            probably going to be a horizontal             |[57P]
            or vertical rectangle, so when 100%           |[57P]
            zoomed out the[ __HOTEL__ ]should be          |[57P]
            __INSCRIBED__ within[ vp0 ].                  |[57P]
                                                          |[57P]
    :------------------------:?_HIGH_LEVEL_CAMERA_OBJECT_?:[57P]
    ?_PLAYER_FOCUS_ANIMATION_? :--------------------------:[57P]
                                                          |[57P]
        @d_cm0@ / @cm0@ : Camera_Marionette_ZERO( 0 )     |[57P]
        @d_cm1@ / @cm1@ : Camera_Marionette_ONE(  1 )     |[57P]
        @d_cmp@ / @cmp@ : Camera_Marionette_PERCENTAGE    |[57P]
        @d_cma@ / @cma@ : Camera_Marionette_ANIMATING?    |[57P]
                                                          |[57P]
        When switching the camera from following one      |[57P]
        player to following another player, we want       |[57P]
        to animate that transition. In order to animate   |[57P]
        transition, we need to know :                     |[57P]
                                                          |[57P]
            1. Are we animating a camera transition ?     |[57P]
               ( use : d_cma for this )                   |[57P]
                                                          |[57P]
            2. Which two players is camera going between ?|[57P]
               ( use : d_cm0 and d_cm1 for this )         |[57P]
                                                          |[57P]
            3. How far along is our animation progress ?  |[57P]
               ( use : d_cmp for this )                   |[57P]
                                                          |[57P]
    :--------------------------:?_PLAYER_FOCUS_ANIMATION_?:[57P]
                                                           [---]
    ?_CAMERA_MAGNITUDE_CONSTANTS_? :----------------------:[58P]
                                                          |[58P]
        @cmj@ / @c_cmj@ : Camera_Magnitude.JOT ( MIN_MAG )|[58P]
        @cmz@ / @c_cmz@ : Camera_Magnitude.ZEN ( MAX_MAG )|[58P]
        @cm0@ / @c_cm0@ : Camera_Magnitude._0_ ( ZER_MAG )|[58P]
                                                          |[58P]
        When interpolating the low level camera's size ,  |[58P]
        we use these 3 magnitudes to determine how big    |[58P]
        [ vp1 ]is in[ discrete_units / planck_units ].    |[58P]
                                                          |[58P]
    :----------------------:?_CAMERA_MAGNITUDE_CONSTANTS_?:[58P]
    ?_WHY_PUTTER_AND_GETTER_? :---------------------------:[58P]
    ?_WHY_GETTER_AND_PUTTER_? :---------------------------:[58P]
                                                          |[58P]
        Direct texture access makes for very bulky        |[58P]
        [ boiler_plate_ish ]code... So let's make         |[58P]
        some accessor functions for this data.            |[58P]
                                                          |[58P]
        These are[ REAL_ACCESSORS ] , not those           |[58P]
        [ OOP_ACCESSORS ]that simply wrap and return      |[58P]
        a[ private_variable ].                            |[58P]
                                                          |[58P]
    :---------------------------:?_WHY_GETTER_AND_PUTTER_?:[58P]
    :---------------------------:?_WHY_PUTTER_AND_GETTER_?:[58P]
    #__PUT_SPRITE_PROPERTY_VALUE__# :---------------------:[58P]
                                                          |[58P]
        Putter code for packing sprite properties into    |[58P]
        the texture memory that is uploaded to GPU.       |[58P]
                                                          |[58P]
        SEE[ _WHY_PUTTER_AND_GETTER_ ]                    |[58P]
                                                          |[58P]
    :---------------------:#__PUT_SPRITE_PROPERTY_VALUE__#:[58P]
    #__GET_SPRITE_PROPERTY_VALUE__# :---------------------:[58P]
                                                          |[58P]
        Getter code for UN-packing sprite property        |[58P]
        values from the cpu-side texture memory that      |[58P]
        is synced with the GPU. ( Gee_Pee_You )           |[58P]
                                                          |[58P]
        SEE[ _WHY_GETTER_AND_PUTTER_ ]                    |[58P]
                                                          |[58P]
    :---------------------:#__GET_SPRITE_PROPERTY_VALUE__#:[58P]

    ?_ITS_WRONG_AND_IMMORAL_? :---------------------------:[59P]
                                                          |[59P]
        @d_sbx@ : WRONG, YOU MEAN[ c _ sbx ]( Const = c_ )|[59P]
        @d_sby@ : WRONG, YOU MEAN[ c _ sby ]( Const = c_ )|[59P]
                                                          |[59P]
        Correcting a mis-spelling of mine.                |[59P]
                                                          |[59P]
    :---------------------------:?_ITS_WRONG_AND_IMMORAL_?:[59P]

    $_SAVE_COLUMNS_$ :------------------------------------:[60P]
                                                          |[60P]
        The only reason this variable ( "u" ) exists      |[60P]
        is to save column space in our source code.       |[60P]
        Yes, I get that it isn't the... best thing...     |[60P]
        But all design choices comes with "pros"          |[60P]
        and "cons". If there was ONE_DESIGN_CHOICE        |[60P]
        that had nothing but "pros" then we would         |[60P]
        all code in identical styles.                     |[60P]
                                                          |[60P]
    :------------------------------------:$_SAVE_COLUMNS_$:[60P]

    $_AMI_WHAT_$ :----------------------------------------:[61P]
                                                          |[61P]
        @AMI@ : Active_Marionette_Index (but all caps)    |[61P]
        @ami@ : Active_Marionette_Index (but all lows)    |[61P]
                                                          |[61P]
        The active marionette index is the index          |[61P]
        representing the sprite that you ,                |[61P]
        the human , are currently controlling.            |[61P]
                                                          |[61P]
    :----------------------------------------:$_AMI_WHAT_$:[61P]
    ?_DISCRETE_UNITS_SPRITE_? :---------------------------:[61P]
                                                          |[61P]
        TAG[ discrete_units_sprite | planks_in_sprite ]   |[61P]
        TAG[ discrete-units-sprite | planks-in-sprite ]   |[61P]
        TAG[ discrete units sprite | planks in sprite ]   |[61P]
        TAG[ discreteunitssprite   | planksinsprite   ]   |[61P]
                                                          |[61P]
        How many discrete units are in a sprite ?         |[61P]
        I know that I have planned for a sprite to        |[61P]
        be exactly the size of one tile, but I know       |[61P]
        that I have a specific and meticulously           |[61P]
        choosen variable name for this that cannot        |[61P]
        collide with "p" for [pixel?player] or            |[61P]
        "f" for [fragment?pixel?player] ?                 |[61P]
                                                          |[61P]
        AH!!! Discrete_Units_Character[ c _ duc ]         |[61P]
                                                          |[61P]
        I don't know why[ c_dus ]is OFF_LIMITS ,          |[61P]
        but I know I put a lot of effort into             |[61P]
        choosing a[ NON_NAME_COLLISION_NAME ].            |[61P]
                                                          |[61P]
        AH! In main game engine ,                         |[61P]
        "dus" is for "Discrete_Unit_Spans".               |[61P]
                                                          |[61P]
    :---------------------------:?_DISCRETE_UNITS_SPRITE_?:[61P]

    #_TARGET_AND_PERCENT_# :------------------------------:[62P]
                                                          |[62P]
        Find the target you are trying to blend           |[62P]
        [ c_cm0 ]AWAY_FROM , and how blended              |[62P]
        AWAY_FROM[ c_cm0 ]you are.                        |[62P]
                                                          |[62P]
        Three possible transitions :                      |[62P]
                                                          |[62P]
            [ c_cm0 ]===>[ c_cm0 ] ( do nothing )         |[62P]
            [ c_cm0 ]===>[ c_cmj ] ( zoomin OUT )         |[62P]
            [ c_cm0 ]===>[ c_cmz ] ( zoomin INN )         |[62P]
                                                          |[62P]
        JOT === small viewport === less data == ZOOMED_INN|[62P]
        ZEN === large viewport === more data == ZOOMED_OUT|[62P]
                                                          |[62P]
        We didn't define what the 3 constants are yet...  |[62P]
        So this code isn't ready yet... Next video we     |[62P]
        need to define what those constants are.          |[62P]
        CONSTANTS[ c_cm0 , c_cmj , c_cmz ]                |[62P]
                                                          |[62P]
    :------------------------------:#_TARGET_AND_PERCENT_#:[62P]

    @v0m@ : YOU_MEAN[ mv0 ]Magnitude_of[ vp0 ]             [63P]
    @v1m@ : YOU_MEAN[ mv1 ]Magnitude_of[ vp1 ]             [63P]

    #_CAMERA_RATIO_# :------------------------------------:[63P]
                                                          |[63P]
        The target[ vp1 ]offscreen data selection         |[63P]
        rectangle needs to be proportional to the         |[63P]
        on-screen pixel rectangle[ vp0 ].                 |[63P]
                                                          |[63P]
        There are two ways we can make this happen :      |[63P]
                                                          |[63P]
            1. We can shrink one axis of[ vp1 ]( crushit )|[63P]
            2. We can grow   one axis of[ vp1 ]( elongit )|[63P]
                                                          |[63P]
            @c_csm_crushit@ : CameraScaleMode.CrushIt     |[63P]
            @c_csm_elongit@ : CameraScaleMode.ElongIt     |[63P]
                                                          |[63P]
        Which mode we use for the camera will be stored   |[63P]
        in a variable called[ d_csm ], the "csm"          |[63P]
        stands for "camera scale mode".                   |[63P]
                                                          |[63P]
            @d_csm@ : DATA(global) - Camera_Scale_Mode    |[63P]
                                                          |[63P]
        We have some variables we will use to figure out  |[63P]
        the final size of[ cmt ]on the[ x and y ]axis.    |[63P]
                                                          |[63P]
            1. @mv0_x@ : Magnitude of[ vp0 ]on X-axis     |[63P]
            2. @mv0_y@ : Magnitude of[ vp0 ]on Y-axis     |[63P]
            3. @fac_x@ : ScaleFactor X (cmt_x=(cmt*fac_x))|[63P]
            4. @fac_y@ : ScaleFactor Y (cmt_y=(cmt*fac_y))|[63P]
                                                          |[63P]
        The final goal is to conver the 1D target         |[63P]
        magnitude[ cmt ]into a 2D target magnitude        |[63P]
        [ cmt_x , cmt_y ]that is proportional to the      |[63P]
        dimensions of[ vp0 ].                             |[63P]
                                                          |[63P]
            0. @cmt@ ::: Camera_Magnitude_Target.(X||Y)   |[63P]
            1. @cmt_x@ : Camera_Magnitude_Target.X        |[63P]
            2. @cmt_x@ : Camera_Magnitude_Target.Y        |[63P]
                                                          |[63P]
    :------------------------------------:#_CAMERA_RATIO_#:[63P]

    ?_CAMERA_MAGNITUDE_CONSTANTS_? :----------------------:[64P]
                                                          |[64P]
        These are the anchor points that define what :    |[64P]
                                                          |[64P]
            1. Zoomed In   100% means ( @c_cmj@ )         |[64P]
            2. Zoomed Out  100% means ( @c_cmz@ )         |[64P]
            3. Zoomed NONE (0%) means ( @c_cm0@ )         |[64P]
                                                          |[64P]
        $_C_M_JOT_$ : @cmj@ : Camera_Magnitude.JOT        |[64P]
        $_C_M_ZEN_$ : @cmz@ : Camera_Magnitude.ZENITH     |[64P]
        $_C_M_NEU_$ : @cm0@ : Camera_Magnitude.NEUTRAL    |[64P]
                                                          |[64P]
    :----------------------:?_CAMERA_MAGNITUDE_CONSTANTS_?:[64P]
    $_0_PER_MAG_$ :---------------------------------------:[65P]
                                                          |[65P]
        The magnitude of X and Y edges of the             |[65P]
        off screen data viewport( vp1 )when               |[65P]
        we are at ZERO_PERCENT_ZOOM.                      |[65P]
                                                          |[65P]
        @0_PER_MAG@ : Zero_Percent_Magnitude              |[65P]
                                                          |[65P]
    :---------------------------------------:$_0_PER_MAG_$:[65P]
    $_1_PER_MAG_$ :---------------------------------------:[65P]
                                                          |[65P]
        The magnitude of X and Y edges of the             |[65P]
        off screen data viewport( vp1 )when               |[65P]
        we are at ONE_HUNDRED_PERCENT_ZOOM.               |[65P]
                                                          |[65P]
        @1_PER_MAG@ : ONE_hundred_Percent_Magnitude       |[65P]
                                                          |[65P]
    :---------------------------------------:$_1_PER_MAG_$:[65P]
    #_SCALE_TO_TARGET_# :---------------------------------:[65P]
                                                          |[65P]
        Scale our[ vp1 ]value by interpolating between    |[65P]
        the starting viewport magnitude and ending        |[65P]
        viewport magnitude, using the interpolation       |[65P]
        perctange as a weight.                            |[65P]
                                                          |[65P]
        $_BEG_PERCENT_$ : Beginning Percentage ( @p_0@ )  |[65P]
        $_END_PERCENT_$ : Ending    Percentage ( @p_1@ )  |[65P]
                                                          |[65P]
    :---------------------------------:#_SCALE_TO_TARGET_#:[65P]

    #_MOVE_TO_TARGET_# :----------------------------------:[66P][---]
                                                          |[66P][---]
       Move                                               |[66P][---]
             LOW_LEVEL_CAMERA so that it's center is aligned  [][66P]
       with HIGH_LEVEL_CAMERA [x,y] discrete unit position    [][66P]
       we set at the very top of the function.            |[66P][---]
                                                          |[66P][---]
       The[ LOW_LEVEL_CAMERA ]( vp1 )does __NOT__         |[66P][---]
       have a concept of an "origin", it is just          |[66P][---]
       a rectangle with[left,right,top,bottom]edges.      |[66P][---]
       ( IN THAT EXACT ORDER [x_0,x_1,y_0,y_1 ] )         |[66P][---]
       ( IN THAT EXACT ORDER [lef,rig,top,bot ] )         |[66P][---]
                                                          |[66P]
        #_POST_ADJUSTMENTS_#:-----------------------------:[66P]
                                                          |[66P]
            Let's make sure our math is correct using     |[66P]
            an extreme example of a 1x1 and 2x2 viewport: |[66P]
                                                          |[66P]
            Example 1 , 1x1 : ( ODD_MAGNITUDE )           |[66P]
                                                          |[66P]
                    [ ] 1x1 , 1/2 == 0.5 ==> 0            |[66P]
                    Extending viewport on all sides       |[66P]
                    by ZERO Viewport is ODD, so no        |[66P]
                    [ POST_ADJUSTMENTS ]                  |[66P]
                                                          |[66P]
            Example 2 , 2x2 : ( EVEN_MAGNITUDE )          |[66P]
                                                          |[66P]
                 [ ][ ]                                   |[66P]
                 [ ][ ] 2x2 , 2/2 == 1.0 ==> 1            |[66P]
                Extending viewport on all sides by ONE :  |[66P]
                                                          |[66P]
                              [ ][ ][ ]                   |[66P]
                    [A] ===>  [ ][A][ ]                   |[66P]
                              [ ][ ][ ]                   |[66P]
                                                          |[66P]
                Extension by 1 on all sides creates wrong |[66P]
                size of 3_X_3 , we wanted a 2_X_2 . But   |[66P]
                according to our rules an                 |[66P]
                      [ EVEN_MAGNITUDE ]                  |[66P]
                gets a[ POST_ADJUSTMENT ]where we         |[66P]
                ADD_ONE to the minimum bounds to          |[66P]
                bring it in.                              |[66P]
                                                          |[66P]
                    [ ][ ][ ]                             |[66P]
                    [ ][A][ ] ==( vp1 += 1 )==>  [A][ ]   |[66P]
                    [ ][ ][ ]                    [ ][ ]   |[66P]
                                                          |[66P]
                And look at that! The origin point is     |[66P]
                in the[ TOP_LEFT ]of the 2_X_2 cluster    |[66P]
                of points representing the origin !       |[66P]
                                                          |[66P]
                We've Done It Peeps !                     |[66P]
                                                          |[66P]
        :----------------------------:#_POST_ADJUSTMENTS_#:[66P]
                                                          |[66P][---]
    :----------------------------------:#_MOVE_TO_TARGET_#:[66P][---]

    $_NO_MORE_DELTA_XY_$ :--------------------------------:[67P]
                                                          |[67P]
        This code is no longer needed.                    |[67P]
                                                          |[67P]
    let d_x =( d_orx * 0x7FFFFF );//:OFF_RAW_X*S[30P]://  |[67P]
    let d_y =( d_ory * 0x7FFFFF );//:OFF_RAW_Y*S[30P]://  |[67P]
                                            //::[---]://  |[67P]
        d_x =( d_x * 8 );//:$_MOVE_FASTER_X_$   [34P]://  |[67P]
        d_y =( d_y * 8 );//:$_MOVE_FASTER_Y_$   [34P]://  |[67P]
                                                          |[67P]
                                                          |[67P]
    :--------------------------------: $_NO_MORE_DELTA_XY_$[67P]

    #_PER_ON_VP1_# :--------------------------------------:[68P]
                                                          |[68P]
        @PER_ON_VP1@ : PERcentage_ON_ViewPort1            |[68P]
               @PER@ : PERcentage                         |[68P]
               @VP1@ : View_Port_1 (off_screen_data_vp)   |[68P]
                                                          |[68P]
        Figure out the sprite's percentage position on    |[68P]
        the offscreen data selection viewport. ( vp1 ).   |[68P]
                                                          |[68P]
        This percent position could very well be outside  |[68P]
        of the bounds of vp1 (viewport #1).               |[68P]
                                                          |[68P]
        If this is the case, the percentage will          |[68P]
        be negative or greater than one.                  |[68P]
        This intial percentage is a [ 0 -to- 1 ]          |[68P]
        percentage and __NOT__ a NDC[-1 -to +1 ]          |[68P]
        percentage. Though later this top-left            |[68P]
        style percentage needs to be converted            |[68P]
        into the "center of screen" style NDC             |[68P]
        coordinate.                                       |[68P]
                                                          |[68P]
                                                          |[68P]
    :--------------------------------------:#_PER_ON_VP1_#:[68P]
    #_CONVERT_TO_NDC_# :----------------------------------:[68P]
                                                          |[68P]
        Convert the[ 0.0 to 1.0 ]percentage on the        |[68P]
        offscreen data selection viewport( [ poi_vp1 ] )  |[68P]
        into a NDC value ( Normalized_Device_Coordinate ).|[68P]
        An NDC value has a centerpoint at 0.0 and the     |[68P]
        lower and upper bounding edges are at -1.0 and    |[68P]
        +1.0 respectively.                                |[68P]
                                                          |[68P]
    :----------------------------------:#_CONVERT_TO_NDC_#:[68P]

    #_CALC_DUG_XY_# :-------------------------------------:[69P]
                                                          |[69P]
        Calculate DiscreteUnitGlobal( DUG ).              |[69P]
        DUG is the global address of ANYTHING             |[69P]
        within our renderable space. DUG's units          |[69P]
        are called "discrete_units". Our discrete         |[69P]
        units are[ digital_planck_units ].                |[69P]
                                                          |[69P]
        Like the[ math_dude ]named[ max_planck ].         |[69P]
                                                          |[69P]
    :-------------------------------------:#_CALC_DUG_XY_#:[69P]

    #_FOR_RENDERING_TILE_GTX_GTY_# :----------------------:[70P]
                                                          |[70P]
        These binary numbers actually encode 8_X_8        |[70P]
        bitmaps so we can draw the number[ 0 -to- 9 ]     |[70P]
        within our renderer. We will use this number      |[70P]
        rendering to label the[ gtx,gty ]of               |[70P]
        [ EVERY_SINGLE_TILE ]. It won't look pretty,      |[70P]
        but as long as we can confirm without a           |[70P]
        [ SHADOW_OF_A_DOUBT ]a given tiles[ GTX,GTY ],    |[70P]
        then we've done our job.                          |[70P]
                                                          |[70P]
        We are hoping this will help us figure out        |[70P]
        where the bug is in our rendering code for        |[70P]
        the sprite's position on screen.                  |[70P]
                                                          |[70P]
        Numbers Stolen From The[ BINFONT ]sub-system      |[70P]
        of my main game engine : ATOMIC_IVY_MMO.JS(AIM)   |[70P]
        AIM_SOURCE_CODE[ www.github.com/KanjiCoder/AIM ]  |[70P]
                                                          |[70P]
    :----------------------:#_FOR_RENDERING_TILE_GTX_GTY_#:[70P]

                                                           [---]
*** ******************* #__DOC_SEC__#:[004_POI]:**/ // [004_POI]
                                                    // [---=---]
</script><!-- //////////////////////////////////////// [003_POI][002_POI][001_POI] -->

